./agent_g.py :
<<<
import yfinance as yf
import pandas as pd
import numpy as np

class ComplianceAgent:
    def __init__(self):
        self.regulations = {
            "max_single_stock_exposure": 0.30,
            "min_stocks_count": 5,
            "restricted_sectors": ["Tobacco", "Gambling", "Weapons"],
            "esg_score_threshold": 50,
            "max_sector_exposure": 0.40,
            "min_developed_markets_exposure": 0.60,
            "max_volatility": 0.25
        }

    def get_sector_info(self, ticker):
        try:
            stock = yf.Ticker(ticker)
            return stock.info.get('sector', 'Unknown')
        except:
            return 'Unknown'

    def get_esg_score(self, ticker):
        try:
            stock = yf.Ticker(ticker)
            return stock.info.get('esgScore', 0)
        except:
            return 0

    def get_market_type(self, ticker):
        try:
            stock = yf.Ticker(ticker)
            country = stock.info.get('country', 'Unknown')
            developed_markets = ['United States', 'Canada', 'United Kingdom', 'Germany', 'France', 'Japan', 'Australia']
            return 'Developed' if country in developed_markets else 'Emerging'
        except:
            return 'Unknown'

    def calculate_volatility(self, tickers, weights):
        data = yf.download(tickers, period="1y")['Adj Close']
        returns = data.pct_change().dropna()
        portfolio_std = np.sqrt(np.dot(weights.T, np.dot(returns.cov(), weights))) * np.sqrt(252)
        return portfolio_std

    def check_compliance(self, portfolio):
        violations = []
        warnings = []
        portfolio_dict = {stock['symbol']: stock['weight'] / 100 for stock in portfolio}
        
        # Vérification de l'exposition maximale à un seul stock
        for symbol, weight in portfolio_dict.items():
            if weight > self.regulations["max_single_stock_exposure"]:
                violations.append(f"L'exposition à {symbol} ({weight:.2%}) dépasse le maximum autorisé ({self.regulations['max_single_stock_exposure']:.2%})")

        # Vérification du nombre minimum de stocks
        if len(portfolio) < self.regulations["min_stocks_count"]:
            violations.append(f"Le portefeuille ne contient que {len(portfolio)} actions. Le minimum requis est de {self.regulations['min_stocks_count']}")

        # Vérification des secteurs et de l'exposition aux secteurs
        sector_exposure = {}
        for stock in portfolio:
            sector = self.get_sector_info(stock['symbol'])
            if sector in self.regulations["restricted_sectors"]:
                violations.append(f"{stock['symbol']} appartient au secteur restreint: {sector}")
            sector_exposure[sector] = sector_exposure.get(sector, 0) + stock['weight'] / 100

        for sector, exposure in sector_exposure.items():
            if exposure > self.regulations["max_sector_exposure"]:
                violations.append(f"L'exposition au secteur {sector} ({exposure:.2%}) dépasse le maximum autorisé ({self.regulations['max_sector_exposure']:.2%})")

        # Vérification des scores ESG
        for stock in portfolio:
            esg_score = self.get_esg_score(stock['symbol'])
            if esg_score < self.regulations["esg_score_threshold"]:
                warnings.append(f"{stock['symbol']} a un score ESG de {esg_score}, inférieur au seuil recommandé de {self.regulations['esg_score_threshold']}")

        # Vérification de l'exposition aux marchés développés
        developed_exposure = sum(stock['weight'] / 100 for stock in portfolio if self.get_market_type(stock['symbol']) == 'Developed')
        if developed_exposure < self.regulations["min_developed_markets_exposure"]:
            warnings.append(f"L'exposition aux marchés développés ({developed_exposure:.2%}) est inférieure au minimum recommandé ({self.regulations['min_developed_markets_exposure']:.2%})")

        # Vérification de la volatilité du portefeuille
        tickers = [stock['symbol'] for stock in portfolio]
        weights = np.array([stock['weight'] / 100 for stock in portfolio])
        volatility = self.calculate_volatility(tickers, weights)
        if volatility > self.regulations["max_volatility"]:
            warnings.append(f"La volatilité du portefeuille ({volatility:.2%}) dépasse le maximum recommandé ({self.regulations['max_volatility']:.2%})")

        rapport = f"""
Analyse de conformité avancée

Statut de conformité: {"Non conforme" if violations else "Conforme avec avertissements" if warnings else "Totalement conforme"}

1. Violations majeures:
"""
        if violations:
            for violation in violations:
                rapport += f"   - {violation}\n"
        else:
            rapport += "   Aucune violation majeure détectée.\n"

        rapport += f"""
2. Avertissements et recommandations:
"""
        if warnings:
            for warning in warnings:
                rapport += f"   - {warning}\n"
        else:
            rapport += "   Aucun avertissement à signaler.\n"

        rapport += f"""
3. Exposition sectorielle:
"""
        for sector, exposure in sector_exposure.items():
            rapport += f"   - {sector}: {exposure:.2%}\n"

        rapport += f"""
4. Exposition géographique:
   - Marchés développés: {developed_exposure:.2%}
   - Marchés émergents: {1 - developed_exposure:.2%}

5. Mesures de risque:
   - Volatilité du portefeuille: {volatility:.2%}

Conclusion:
Cette analyse de conformité avancée fournit un aperçu détaillé des potentielles violations réglementaires et des zones de risque dans le portefeuille. 

Points clés à retenir:
1. {f"Le portefeuille présente {len(violations)} violation(s) majeure(s) qui doivent être adressées immédiatement." if violations else "Aucune violation majeure n'a été détectée."}
2. {f"Il y a {len(warnings)} avertissement(s) qui méritent une attention particulière pour améliorer la conformité et réduire les risques." if warnings else "Aucun avertissement n'a été émis."}
3. L'exposition sectorielle la plus élevée est dans {max(sector_exposure, key=sector_exposure.get)} à {max(sector_exposure.values()):.2%}.
4. L'exposition aux marchés développés est de {developed_exposure:.2%}, {"ce qui est conforme" if developed_exposure >= self.regulations["min_developed_markets_exposure"] else "ce qui est inférieur"} aux recommandations.
5. La volatilité du portefeuille est {"conforme" if volatility <= self.regulations["max_volatility"] else "supérieure"} aux limites recommandées.

Recommandations:
1. {f"Adresser immédiatement les violations en ajustant les positions dans {', '.join([v.split()[3] for v in violations if 'exposition' in v])}." if violations else "Maintenir la conformité actuelle du portefeuille."}
2. {"Réévaluer l'exposition aux secteurs à haut risque et envisager une diversification accrue." if any(sector in self.regulations["restricted_sectors"] for sector in sector_exposure) else ""}
3. {"Examiner les positions ayant des scores ESG faibles et envisager des alternatives plus durables." if any("ESG" in w for w in warnings) else ""}
4. {"Considérer une augmentation de l'exposition aux marchés développés pour améliorer la stabilité du portefeuille." if developed_exposure < self.regulations["min_developed_markets_exposure"] else ""}
5. {"Envisager des stratégies de réduction de la volatilité, comme l'ajout d'actifs à faible corrélation." if volatility > self.regulations["max_volatility"] else ""}

Les gestionnaires de portefeuille devraient utiliser ces informations pour ajuster la composition du portefeuille afin d'assurer la conformité réglementaire et d'optimiser le profil risque/rendement en fonction des objectifs d'investissement.
"""
        return rapport

compliance_agent = ComplianceAgent()
>>>

./agent_c.py :
<<<
import yfinance as yf
from sklearn.linear_model import LinearRegression
import numpy as np

class FinancialModelingAgent:
    def analyze(self, ticker):
        stock = yf.Ticker(ticker)
        hist = stock.history(period="1y")
        returns = hist['Close'].pct_change().dropna()
        volatility = returns.std() * np.sqrt(252)
        X = np.array(range(30)).reshape(-1, 1)
        y = hist['Close'].tail(30).values
        model = LinearRegression().fit(X, y)
        next_price = model.predict([[30]])[0]
        info = stock.info
        pe_ratio = info.get('trailingPE', 'N/A')
        pb_ratio = info.get('priceToBook', 'N/A')
        dividend_yield = info.get('dividendYield', 'N/A')
        if dividend_yield != 'N/A':
            dividend_yield *= 100  # Convertir en pourcentage

        rapport = f"""
Analyse financière de {ticker}

Prix actuel: {hist['Close'].iloc[-1]:.2f} USD
Prix prédit (prochain jour): {next_price:.2f} USD
Volatilité annualisée: {volatility:.2%}
Volume moyen d'échanges: {hist['Volume'].mean():.0f} actions

Ratios financiers:
- Ratio Cours/Bénéfice (P/E): {pe_ratio if pe_ratio != 'N/A' else 'Non disponible'}
- Ratio Cours/Valeur Comptable (P/B): {pb_ratio if pb_ratio != 'N/A' else 'Non disponible'}
- Rendement du dividende: {f'{dividend_yield:.2f}%' if dividend_yield != 'N/A' else 'Non disponible'}

Fourchette de prix sur 52 semaines:
- Plus haut: {hist['High'].max():.2f} USD
- Plus bas: {hist['Low'].min():.2f} USD

Interprétation:
1. Performance: {'Le prix prédit est supérieur au prix actuel, suggérant une tendance haussière potentielle.' if next_price > hist['Close'].iloc[-1] else 'Le prix prédit est inférieur au prix actuel, suggérant une possible baisse à court terme.'}
2. Volatilité: {'La volatilité est élevée, indiquant un risque important.' if volatility > 0.3 else 'La volatilité est modérée, suggérant un risque moyen.'}
3. Valorisation: {'Le ratio P/E suggère que l\'action pourrait être surévaluée.' if pe_ratio != 'N/A' and pe_ratio > 25 else 'Le ratio P/E semble raisonnable.' if pe_ratio != 'N/A' else 'Impossible d\'évaluer la valorisation sans le ratio P/E.'}

Conclusion: Cette analyse fournit un aperçu de la situation financière actuelle de {ticker}. Les investisseurs devraient considérer ces informations en conjonction avec une analyse plus approfondie du secteur et des nouvelles récentes de l'entreprise avant de prendre des décisions d'investissement.
        """
        return rapport

financial_modeling_agent = FinancialModelingAgent()
>>>

./agent_b.py :
<<<
import requests
from textblob import TextBlob
from collections import Counter, defaultdict
import re
from datetime import datetime, timedelta

class SentimentAnalysisAgent:
    def __init__(self):
        self.news_api_key = "c6cc145ad227419c88756838786b70d1"
        self.stop_words = set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'])

    def get_news(self, query, days=7):
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        url = "https://newsapi.org/v2/everything"
        params = {
            "q": query,
            "from": start_date.isoformat(),
            "to": end_date.isoformat(),
            "sortBy": "relevancy",
            "language": "en",
            "pageSize": 100,
            "apiKey": self.news_api_key
        }
        response = requests.get(url, params=params)
        if response.status_code == 200:
            return response.json().get('articles', [])
        else:
            print(f"Erreur lors de la requête: {response.text}")
            return []

    def analyze_sentiment(self, text):
        return TextBlob(text).sentiment.polarity

    def extract_keywords(self, text):
        words = re.findall(r'\w+', text.lower())
        return [word for word in words if word not in self.stop_words and len(word) > 2]

    def categorize_keywords(self, keywords):
        categories = {
            "Produits": ["iphone", "mac", "ipad", "watch"],
            "Financier": ["revenue", "profit", "earnings", "shares", "stock"],
            "Marché": ["market", "competition", "industry", "consumer"],
            "Innovation": ["technology", "innovation", "development", "research"],
            "Services": ["services", "cloud", "streaming", "subscription"]
        }
        categorized = defaultdict(list)
        for word, count in keywords.items():
            for category, terms in categories.items():
                if word in terms:
                    categorized[category].append((word, count))
                    break
            else:
                categorized["Autres"].append((word, count))
        return dict(categorized)

    def analyze(self, company):
        news = self.get_news(company)
        if not news:
            return "Analyse impossible : aucun article trouvé."

        sentiments = []
        keywords = Counter()
        sources = Counter()
        theme_sentiments = defaultdict(list)

        for article in news:
            title = article.get('title', '')
            description = article.get('description', '')
            text = f"{title} {description}"
            sentiment = self.analyze_sentiment(text)
            sentiments.append(sentiment)
            # Correction ici : utilisez extend() au lieu de update() pour une liste
            keywords.extend(self.extract_keywords(text))
            sources[article.get('source', {}).get('name', 'Unknown')] += 1
            
            # Analyse de sentiment par thème
            for theme, theme_keywords in self.themes.items():
                if any(keyword in text.lower() for keyword in theme_keywords):
                    theme_sentiments[theme].append(sentiment)

        avg_sentiment = sum(sentiments) / len(sentiments) if sentiments else 0
        positive_articles = sum(1 for s in sentiments if s > 0.1)
        negative_articles = sum(1 for s in sentiments if s < -0.1)
        neutral_articles = len(sentiments) - positive_articles - negative_articles

        categorized_keywords = self.categorize_keywords(keywords)

        rapport = f"""
Analyse de sentiment pour {company}

1. Aperçu général:
   Période analysée: 7 derniers jours
   Nombre d'articles analysés: {len(sentiments)}
   Sentiment moyen: {avg_sentiment:.2f} (sur une échelle de -1 à 1)
   Catégorie de sentiment: {"Positif" if avg_sentiment > 0.1 else "Négatif" if avg_sentiment < -0.1 else "Neutre"}
   Distribution du sentiment:
     - Articles positifs: {positive_articles} ({positive_articles/len(sentiments)*100:.1f}%)
     - Articles neutres: {neutral_articles} ({neutral_articles/len(sentiments)*100:.1f}%)
     - Articles négatifs: {negative_articles} ({negative_articles/len(sentiments)*100:.1f}%)

2. Interprétation:
   {self.get_interpretation(avg_sentiment, company)}

3. Mots-clés fréquents par catégorie:
"""
        for category, words in categorized_keywords.items():
            rapport += f"   {category}: {', '.join([f'{word} ({count})' for word, count in words[:5]])}\n"

        rapport += f"""
4. Thèmes principaux et leur sentiment:
"""
        for theme, sentiments in theme_sentiments.items():
            avg_theme_sentiment = sum(sentiments) / len(sentiments) if sentiments else 0
            rapport += f"   {theme}: Sentiment moyen {avg_theme_sentiment:.2f}, Mentions: {len(sentiments)}\n"

        rapport += f"""
5. Principales sources d'information:
   {', '.join([f"{source} ({count})" for source, count in sources.most_common(5)])}

6. Articles représentatifs:
"""
        sorted_articles = sorted(news, key=lambda x: abs(self.analyze_sentiment(x['title'])), reverse=True)
        for i, article in enumerate(sorted_articles[:3], 1):
            title = article.get('title', 'Titre non disponible')
            sentiment = self.analyze_sentiment(title)
            rapport += f"   {i}. {title}\n      Sentiment: {sentiment:.2f}\n      Source: {article.get('source', {}).get('name', 'Non spécifiée')}\n      Date: {article.get('publishedAt', 'Non spécifiée')}\n\n"

        rapport += f"""
7. Analyse approfondie:
   a) Tendance générale: Le sentiment global est {"positif" if avg_sentiment > 0 else "négatif" if avg_sentiment < 0 else "neutre"}, suggérant une perception {"favorable" if avg_sentiment > 0 else "défavorable" if avg_sentiment < 0 else "mitigée"} de {company}.
   b) Contexte: Les discussions autour de {company} se concentrent principalement sur {', '.join([cat for cat, words in categorized_keywords.items() if words][:3])}.
   c) Évolution: {self.sentiment_evolution(sentiments)}
   d) Implications: {self.get_implications(avg_sentiment, theme_sentiments)}

8. Recommandations:
   {self.get_recommendations(avg_sentiment, categorized_keywords, theme_sentiments, company)}

Cette analyse offre un aperçu de la perception actuelle de {company} basée sur les articles récents.
Les investisseurs et parties prenantes devraient utiliser ces informations en conjonction avec d'autres
analyses financières et sectorielles pour une compréhension complète de la situation de l'entreprise.
"""
        return rapport

    def get_interpretation(self, avg_sentiment, company):
        if avg_sentiment > 0.3:
            strength = "très positive"
        elif avg_sentiment > 0.1:
            strength = "plutôt positive"
        elif avg_sentiment < -0.3:
            strength = "très négative"
        elif avg_sentiment < -0.1:
            strength = "plutôt négative"
        else:
            strength = "neutre"

        return f"La perception de {company} semble être {strength}. Cela pourrait être influencé par des événements récents, des annonces de l'entreprise, ou des tendances plus larges du marché."

    def sentiment_evolution(self, sentiments):
        first_half = sentiments[:len(sentiments)//2]
        second_half = sentiments[len(sentiments)//2:]
        avg_first = sum(first_half) / len(first_half) if first_half else 0
        avg_second = sum(second_half) / len(second_half) if second_half else 0
        
        if avg_second > avg_first + 0.1:
            return "Le sentiment semble s'améliorer au fil du temps."
        elif avg_second < avg_first - 0.1:
            return "Le sentiment semble se détériorer au fil du temps."
        else:
            return "Le sentiment reste relativement stable sur la période analysée."

    def get_implications(self, avg_sentiment, theme_sentiments):
        implications = []
        if avg_sentiment > 0.1:
            implications.append("Une perception positive pourrait indiquer des opportunités de croissance ou des développements favorables.")
        elif avg_sentiment < -0.1:
            implications.append("Une perception négative pourrait signaler des défis ou des controverses à surveiller.")
        else:
            implications.append("Une perception neutre suggère un équilibre entre les aspects positifs et négatifs.")

        for theme, sentiments in theme_sentiments.items():
            avg_theme_sentiment = sum(sentiments) / len(sentiments) if sentiments else 0
            if avg_theme_sentiment > 0.2:
                implications.append(f"Le thème '{theme}' est perçu très positivement, ce qui pourrait être un point fort pour l'entreprise.")
            elif avg_theme_sentiment < -0.2:
                implications.append(f"Le thème '{theme}' est perçu négativement, ce qui pourrait nécessiter une attention particulière.")

        return " ".join(implications)

    def get_recommendations(self, avg_sentiment, categorized_keywords, theme_sentiments, company):
        recommendations = []
        if avg_sentiment > 0.1:
            recommendations.append(f"Capitaliser sur le sentiment positif pour renforcer la position de {company}.")
        elif avg_sentiment < -0.1:
            recommendations.append(f"Adresser les préoccupations soulevées pour améliorer la perception de {company}.")
        else:
            recommendations.append(f"Surveiller de près les développements futurs pour détecter tout changement de perception de {company}.")

        top_categories = [cat for cat, words in categorized_keywords.items() if words][:2]
        recommendations.append(f"Approfondir l'analyse des catégories {' et '.join(top_categories)}.")

        negative_themes = [theme for theme, sentiments in theme_sentiments.items() if sum(sentiments) / len(sentiments) < -0.1]
        if negative_themes:
            recommendations.append(f"Porter une attention particulière aux thèmes perçus négativement : {', '.join(negative_themes)}.")

        recommendations.append("Diversifier les sources d'information pour obtenir une vue plus complète de la perception de l'entreprise.")
        recommendations.append(f"Continuer à suivre l'évolution du sentiment dans le temps pour identifier les tendances à long terme et les facteurs influençant la perception de {company}.")

        return "\n   - ".join(recommendations)

    themes = {
        "Innovation": ["innovation", "technology", "new", "launch"],
        "Financial Performance": ["revenue", "profit", "earnings", "growth"],
        "Market Position": ["market", "share", "competition", "leader"],
        "Product": ["iphone", "mac", "ipad", "watch"],
        "Services": ["services", "cloud", "streaming", "subscription"]
    }

sentiment_agent = SentimentAnalysisAgent()

>>>

./agent_f.py :
<<<
from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
import io
import yfinance as yf
import numpy as np
import base64

class ReportingAgent:
    def _generate_portfolio_optimization_report(self, optimization_result):
        report = "Rapport d'Optimisation du Portefeuille\n\n"
        report += "Poids Optimaux:\n"
        for ticker, weight in optimization_result['optimal_weights'].items():
            report += f"  - {ticker}: {weight:.2%}\n"
        report += f"\nRendement Annuel Attendu: {optimization_result['expected_return']:.2%}\n"
        report += f"Volatilité Annuelle: {optimization_result['volatility']:.2%}\n"
        report += f"Ratio de Sharpe: {optimization_result['sharpe_ratio']:.2f}\n"
        return report

    def generate_report(self, portfolio):
        if not portfolio:
            return {"error": "Aucun portefeuille trouvé pour cet utilisateur"}
        
        report = ""

        for stock in portfolio:
            report += self._generate_stock_report(stock)
        
        report_md = f"""
{report}
    """
        # Création des graphiques
        figs = self._create_graphs(portfolio)
        
    
        # Conversion des graphiques en base64
        graphs_base64 = []
        for fig in figs:
            buf = io.BytesIO()
            fig.savefig(buf, format='png')
            buf.seek(0)
            graphs_base64.append(base64.b64encode(buf.getvalue()).decode('utf-8'))

        # Création du résultat formaté
        formatted_result = {
            "content": report_md,
            "graphs": graphs_base64
        }

        return formatted_result

    def _generate_stock_report(self, stock):
        symbol = stock['symbol']
        ticker = yf.Ticker(symbol)
        info = ticker.info
        
        hist = ticker.history(period="1y")
        volatility = hist['Close'].pct_change().std() * (252 ** 0.5)  # Volatilité annualisée
        
        report = f"## Action : {symbol}\n\n"
        report += f"- Prix actuel : {info.get('currentPrice', 'N/A'):.2f} €\n"
        report += f"- Prix cible (moyenne des analystes) : {info.get('targetMeanPrice', 'N/A'):.2f} €\n"
        report += f"- Volatilité (1 an) : {volatility:.2%}\n"
        report += f"- Volume moyen (10 jours) : {info.get('averageVolume10days', 'N/A'):,.0f}\n"
        report += f"- Ratio P/E : {info.get('trailingPE', 'N/A'):.2f}\n"
        report += f"- Ratio P/B : {info.get('priceToBook', 'N/A'):.2f}\n"
        report += f"- Rendement du dividende : {info.get('dividendYield', 0):.2%}\n"
        report += f"- Plus haut sur 52 semaines : {info.get('fiftyTwoWeekHigh', 'N/A'):.2f} €\n"
        report += f"- Plus bas sur 52 semaines : {info.get('fiftyTwoWeekLow', 'N/A'):.2f} €\n"
        report += f"- Poids dans le portefeuille : {stock['weight']:.2f}%\n"
        report += f"- Prix d'entrée : {stock['entry_price']:.2f} €\n\n"
        return report

    def _create_graphs(self, portfolio):
        figs = []
        
        # Graphique 1 : Allocation du portefeuille
        fig1 = Figure(figsize=(10, 6))
        ax1 = fig1.add_subplot(111)
        symbols = [stock['symbol'] for stock in portfolio]
        weights = [stock['weight'] for stock in portfolio]
        ax1.pie(weights, labels=symbols, autopct='%1.1f%%')
        ax1.set_title('Allocation du Portefeuille')
        figs.append(fig1)
        
        # Récupération des données yfinance
        data = {}
        for stock in portfolio:
            ticker = yf.Ticker(stock['symbol'])
            info = ticker.info
            hist = ticker.history(period="1y")
            data[stock['symbol']] = {
                'current_price': info.get('currentPrice', stock['entry_price']),
                'target_price': info.get('targetMeanPrice', stock['entry_price']),
                'volatility': hist['Close'].pct_change().std() * np.sqrt(252),
                'volume': info.get('averageVolume', 0)
            }
        
        # Graphique 2 : Prix actuels vs Prix cibles
        fig2 = Figure(figsize=(10, 6))
        ax2 = fig2.add_subplot(111)
        current_prices = [data[s]['current_price'] for s in symbols]
        target_prices = [data[s]['target_price'] for s in symbols]
        x = range(len(symbols))
        width = 0.35
        ax2.bar([i - width/2 for i in x], current_prices, width, label='Prix Actuel')
        ax2.bar([i + width/2 for i in x], target_prices, width, label='Prix Cible')
        ax2.set_ylabel('Prix')
        ax2.set_title('Prix Actuels vs Prix Cibles')
        ax2.set_xticks(x)
        ax2.set_xticklabels(symbols, rotation=45)
        ax2.legend()
        figs.append(fig2)
        
        # Graphique 3 : Volatilité
        fig3 = Figure(figsize=(10, 6))
        ax3 = fig3.add_subplot(111)
        volatilities = [data[s]['volatility'] for s in symbols]
        ax3.bar(symbols, volatilities)
        ax3.set_ylabel('Volatilité Annualisée')
        ax3.set_title('Volatilité des Actions')
        ax3.set_xticklabels(symbols, rotation=45)
        figs.append(fig3)
        
        # Graphique 4 : Volume moyen
        fig4 = Figure(figsize=(10, 6))
        ax4 = fig4.add_subplot(111)
        volumes = [data[s]['volume'] for s in symbols]
        ax4.bar(symbols, volumes)
        ax4.set_ylabel('Volume Moyen')
        ax4.set_title('Volume Moyen des Actions')
        ax4.set_xticklabels(symbols, rotation=45)
        figs.append(fig4)
        
        return figs

reporting_agent = ReportingAgent()
>>>

./agent_i.py :
<<<
import openai
import yfinance as yf

class InvestmentRecommendationAgent:
    def __init__(self):
        self.client = openai.OpenAI()

    def get_recommendation(self, portfolio, risk_profile):
        # Récupérer les données de base pour le portfolio
        portfolio_data = {}
        for ticker in portfolio:
            stock = yf.Ticker(ticker)
            info = stock.info
            portfolio_data[ticker] = {
                "sector": info.get('sector', 'Unknown'),
                "industry": info.get('industry', 'Unknown'),
                "current_price": info.get('currentPrice', 0),
                "target_price": info.get('targetMeanPrice', 0)
            }

        # Préparer les données pour l'analyse
        portfolio_str = "\n".join([f"{ticker}: {data}" for ticker, data in portfolio_data.items()])
        print(portfolio_data)
        print(portfolio)
        response = self.client.chat.completions.create(
            model="gpt-4o-2024-08-06",
            messages=[
                {"role": "system", "content": "Vous êtes un conseiller en investissement financier expert. Votre tâche est de fournir des recommandations d'investissement personnalisées basées sur le portefeuille actuel et le profil de risque de l'investisseur."},
                {"role": "system", "content": "Dans votre analyse, veuillez inclure :\n1) Une évaluation de la diversification actuelle du portefeuille.\n2) Des recommandations spécifiques pour optimiser le portefeuille en fonction du profil de risque.\n3) Des suggestions d'actions à acheter, vendre ou conserver, avec des justifications.\n4) Une analyse des secteurs sous-représentés ou surreprésentés.\n5) Des considérations sur l'équilibre entre croissance et valeur.\n6) Des recommandations sur la répartition géographique si pertinent.\n\nAssurez-vous que vos recommandations sont cohérentes avec le profil de risque fourni et basées sur les données financières actuelles."},
                {"role": "user", "content": f"Voici le portefeuille actuel :\n{portfolio_str}\n\nLe profil de risque de l'investisseur est : {risk_profile}\n\nVeuillez fournir des recommandations d'investissement détaillées."}
            ],
            temperature=0.5,
            max_tokens=1500
        )

        return response.choices[0].message.content.strip()

investment_recommendation_agent = InvestmentRecommendationAgent()
>>>

./agent_h.py :
<<<
import openai
import yfinance as yf

class MarketSentimentAgent:
    def __init__(self):
        self.client = openai.OpenAI()

    def analyze_sentiment(self, ticker, summary="Aucun résumé fourni"):
        # Récupérer les dernières nouvelles sur le ticker
        stock = yf.Ticker(ticker)
        news = stock.news[:5]  # Prendre les 5 dernières nouvelles

        # Analyser le sentiment
        news_texts = [f"Title: {item['title']}\nSummary: {summary}" for item in news]
        combined_text = "\n\n".join(news_texts)

        response = self.client.chat.completions.create(
            model="gpt-4o-2024-08-06",
            messages=[
            {"role": "system", "content": "Vous êtes un analyste financier expert spécialisé dans l'analyse du sentiment du marché. Votre tâche est d'évaluer le sentiment global pour une action spécifique en vous basant sur les dernières nouvelles. Veuillez fournir :"},
            {"role": "system", "content": "1) Une évaluation du sentiment global (positif, négatif, ou neutre) avec une explication concise.\n2) Les principaux facteurs influençant ce sentiment.\n3) Les implications potentielles à court terme pour le cours de l'action.\n4) Tout risque ou opportunité notable identifié dans les nouvelles.\n\nAssurez-vous que votre analyse est objective, basée sur les faits présentés, et utile pour la prise de décision d'investissement."},
            {"role": "user", "content": f"Analysez le sentiment pour l'action {ticker} basé sur ces nouvelles récentes :\n\n{combined_text}"}
            ],
            temperature=0.5,
            max_tokens=800
        )

        return response.choices[0].message.content.strip()

market_sentiment_agent = MarketSentimentAgent()

>>>

./agent_k.py :
<<<
import openai

class UserProfileAgent:
    def __init__(self):
        self.client = openai.OpenAI()

    def analyze_user_profile(self, portfolio, chat_history):
        # Vérifier et préparer les données du portfolio
        if isinstance(portfolio, dict) and 'stocks' in portfolio:
            portfolio_summary = "\n".join([f"{stock['symbol']}: {stock['weight']}%" for stock in portfolio['stocks']])
        elif isinstance(portfolio, list):
            portfolio_summary = "\n".join([f"{stock['symbol']}: {stock['weight']}%" for stock in portfolio])
        else:
            portfolio_summary = "No valid portfolio data available"

        # Vérifier et préparer l'historique du chat
        if isinstance(chat_history, list):
            chat_summary = "\n".join([f"{msg['role']}: {msg['content']}" for msg in chat_history[-5:]])  # Derniers 5 messages
        else:
            chat_summary = "No valid chat history available"

        response = self.client.chat.completions.create(
            model="gpt-4o-2024-08-06",
            messages=[
            {"role": "system", "content": "Vous êtes un analyste financier expert spécialisé dans l'analyse des données historiques des actions. Votre tâche est de fournir une analyse approfondie et des insights pertinents basés sur les données fournies."},
            {"role": "system", "content": "Dans votre analyse, veuillez inclure :\n1) Une évaluation de la performance globale de l'action sur la période donnée.\n2) Une analyse de la volatilité et du risque, y compris l'interprétation du ratio de Sharpe.\n3) Une identification des tendances à court et moyen terme.\n4) Une comparaison avec les indices de marché pertinents si possible.\n5) Des facteurs potentiels qui pourraient expliquer les mouvements de prix observés.\n6) Des points d'attention pour les investisseurs basés sur ces données historiques.\n\nAssurez-vous que votre analyse est objective, basée sur les faits présentés, et utile pour la prise de décision d'investissement."},
            {"role": "user", "content": f"Analysez les données suivantes pour {ticker} du {start_date} au {end_date}:\n{data}"}
            ],
            temperature=0.5,
            max_tokens=1000
        )

        return response.choices[0].message.content.strip()

user_profile_agent = UserProfileAgent()
>>>

./generateur_report.py :
<<<
# Bibliothèques standard
import os
import base64
import json
import re
import textwrap
from datetime import datetime, timedelta
from io import BytesIO
import time

# Bibliothèques tierces
import numpy as np
import pandas as pd
import yfinance as yf
import anthropic
from flask import jsonify
from tqdm import tqdm
from sklearn.decomposition import PCA
import scipy.stats as stats
from functools import lru_cache, wraps
import asyncio
import aiohttp
from fredapi import Fred

# Bibliothèques de visualisation
import plotly.express as px
from plotly import graph_objects as go
from plotly import figure_factory as ff

# Bibliothèques de génération de rapports
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, portrait
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak, Image

anthropic_client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))
fred_api_key = os.environ.get('FRED_API_KEY')  # Stockez votre clé API dans une variable d'environnement
fred = Fred(api_key=fred_api_key)

def timing_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"{func.__name__} a pris {execution_time:.2f} secondes")
        return result
    return wrapper

@timing_decorator
@lru_cache(maxsize=None)
def get_stock_info(symbol):
    ticker = yf.Ticker(symbol)
    return ticker

@timing_decorator
def get_bulk_stock_data(symbols, start_date, end_date):
    data = yf.download(symbols, start=start_date, end=end_date)
    return {symbol: data['Close'][symbol] for symbol in symbols}

@timing_decorator
async def fetch_stock_data(session, url):
    async with session.get(url) as response:
        return await response.json()

@timing_decorator
async def get_multiple_stock_data(urls):
    async with aiohttp.ClientSession() as session:
        tasks = [fetch_stock_data(session, url) for url in urls]
        return await asyncio.gather(*tasks)

@timing_decorator
def process_section(section_func, *args):
    return section_func(*args)

@timing_decorator
def get_fred_data(series_id, start_date, end_date):
    """
    Récupère les données de FRED pour une série spécifique.

    Parameters:
    series_id (str): Identifiant de la série FRED.
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    DataFrame: Données de la série FRED.
    """
    data = fred.get_series(series_id, start_date, end_date)
    return pd.DataFrame(data, columns=[series_id])


@timing_decorator
def generate_ai_content(prompt):
    try:
        message = anthropic_client.messages.create(
            model="claude-3-5-sonnet-20240620",
            max_tokens=1000,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        return message.content[0].text
    except (IndexError, AttributeError) as e:
        print(f"Erreur lors de la récupération de la réponse AI: {e}")
        return ""

@timing_decorator
def create_formatted_paragraph(text, style_name='Normal'):
    """
    Crée un paragraphe formaté avec des retours à la ligne et des puces.
    
    Parameters:
    text (str): Texte brut à formater.
    style_name (str): Nom du style à appliquer.
    
    Returns:
    Paragraph: Un objet Paragraph prêt à être ajouté au document.
    """
    styles = getSampleStyleSheet()
    custom_style = ParagraphStyle(
        name='CustomStyle',
        parent=styles[style_name],
        spaceAfter=12,
        leftIndent=35,
        bulletIndent=20
    )
    
    # Remplacer les retours à la ligne par <br/>
    text = text.replace('\n', '<br/>')
    
    # Remplacer les puces manuelles par des listes HTML
    # Identifier les lignes commençant par '•' et les convertir en éléments de liste
    lines = text.split('<br/>')
    formatted_lines = []
    in_list = False
    
    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith('•'):
            if not in_list:
                formatted_lines.append('<ul>')
                in_list = True
            # Supprimer le caractère de puce et ajouter l'élément de liste
            item = stripped_line.lstrip('•').strip()
            formatted_lines.append(f'<li>{item}</li>')
        else:
            if in_list:
                formatted_lines.append('</ul>')
                in_list = False
            formatted_lines.append(line)
    
    if in_list:
        formatted_lines.append('</ul>')
    
    formatted_text = '<br/>'.join(formatted_lines)
    return Paragraph(formatted_text, custom_style)

@timing_decorator
def clean_text(text):
    if not isinstance(text, str):
        text = str(text)
    # Remplacer les retours à la ligne multiples par un seul
    text = re.sub(r'\n+', '\n', text)
    # Diviser le texte en paragraphes
    paragraphs = text.split('\n')
    # Wrapper chaque paragraphe individuellement
    wrapped_paragraphs = [textwrap.fill(p.strip(), width=80) for p in paragraphs]
    # Rejoindre les paragraphes avec des retours à la ligne doubles
    return '\n\n'.join(wrapped_paragraphs)

@timing_decorator
def calculate_portfolio_performance(portfolio, start_date, end_date):
    """
    Calcule la performance du portefeuille sur une période donnée.

    Parameters:
    portfolio (dict): Informations sur le portefeuille, incluant les actions et leurs poids.
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    tuple: (portfolio_data, returns, weights)
        - portfolio_data (dict): Données de clôture des actions.
        - returns (DataFrame): Rendements quotidiens des actions.
        - weights (ndarray): Poids des actions dans le portefeuille.
    """
    symbols = [stock['symbol'] for stock in portfolio['stocks']]
    portfolio_data = get_bulk_stock_data(symbols, start_date, end_date)
    
    df = pd.DataFrame(portfolio_data)
    returns = df.pct_change().dropna()
    weights = np.array([float(stock['weight']) / 100 for stock in portfolio['stocks']])
    
    return portfolio_data, returns, weights

@timing_decorator
def calculate_portfolio_returns(portfolio_data, weights):
    """
    Calcule les rendements pondérés du portefeuille.

    Parameters:
    portfolio_data (dict): Données de clôture des actions.
    weights (ndarray): Poids des actions dans le portefeuille.

    Returns:
    tuple: (weighted_returns, total_return, annualized_return)
        - weighted_returns (Series): Rendements pondérés quotidiens du portefeuille.
        - total_return (float): Rendement total du portefeuille.
        - annualized_return (float): Rendement annualisé du portefeuille.
    """
    df = pd.DataFrame(portfolio_data)
    returns = df.pct_change().dropna()
    weighted_returns = (returns * weights).sum(axis=1)
    total_return = (1 + weighted_returns).prod() - 1
    annualized_return = (1 + total_return) ** (252 / len(returns)) - 1
    return weighted_returns, total_return, annualized_return

@timing_decorator
def generate_report(data):
    """
    Génère un rapport de performance du portefeuille.

    Parameters:
    data (dict): Données nécessaires pour générer le rapport.

    Returns:
    dict: Un dictionnaire contenant le rapport encodé en base64.
    """
    start_time = time.time()
    
    portfolio = data['portfolio']
    start_date = data.get('start_date', (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d'))
    end_date = data.get('end_date', datetime.now().strftime('%Y-%m-%d'))
    
    # Calcul des rendements et des métriques de performance
    portfolio_data, returns, weights = calculate_portfolio_performance(portfolio, start_date, end_date)
    
    # Calcul des rendements pondérés une seule fois
    weighted_returns, total_return, annualized_return = calculate_portfolio_returns(portfolio_data, weights)
    
    # Création du document PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=portrait(letter), 
                            rightMargin=0.5*inch, leftMargin=0.5*inch, 
                            topMargin=0.5*inch, bottomMargin=0.5*inch)

    elements = []
    
    # Ajoutez les sections non parallélisées
    elements.extend(create_title_page(
        "Rapport de Performance du Portefeuille",
        f"Pour : {data.get('client_name', 'Client Estimé')}",
        f"Date : {datetime.now().strftime('%d/%m/%Y')}"
    ))

    # Table des matières
    elements.append(create_section_header("Table des Matières"))
    elements.append(create_formatted_paragraph("1. Résumé Exécutif", 'Normal'))
    elements.append(create_formatted_paragraph("2. Vue d'Ensemble du Portefeuille", 'Normal'))
    elements.append(create_formatted_paragraph("3. Analyse de Performance", 'Normal'))
    # Ajoutez d'autres sections selon vos besoins
    elements.append(PageBreak())

    # Générez chaque section séquentiellement
    timed_functions = [
        (timing_decorator(generate_executive_summary), portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return),
        (timing_decorator(generate_portfolio_overview), portfolio, portfolio_data, returns, weights),
        (timing_decorator(generate_performance_analysis), portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return, start_date, end_date),
        (timing_decorator(generate_correlation_heatmap), portfolio_data),
        (timing_decorator(generate_monte_carlo_simulation), portfolio, portfolio_data, returns, weights, weighted_returns),
        (timing_decorator(generate_future_outlook), portfolio, portfolio_data, returns, weights),
        (timing_decorator(generate_stock_performance_comparison), portfolio_data, weights),
        (timing_decorator(generate_contribution_to_return), portfolio, portfolio_data, returns, weights),
        (timing_decorator(generate_additional_ratios_table), portfolio, portfolio_data, returns, weights, start_date, end_date),
        (timing_decorator(generate_risk_analysis), portfolio, portfolio_data, returns, weights, weighted_returns),
        (timing_decorator(generate_best_worst_performers), portfolio, portfolio_data, returns, weights),
        (timing_decorator(generate_dividend_table), portfolio),
        (timing_decorator(generate_sector_allocation), portfolio, portfolio_data, returns, weights),
        (timing_decorator(generate_stress_tests), portfolio, portfolio_data, returns, weights, weighted_returns),
        (timing_decorator(generate_recommendations), portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return),
    ]

    for func, *args in timed_functions:
        elements.extend(func(*args))
        
    # Glossaire et avertissements
    elements.append(create_section_header("Glossaire"))
    elements.extend(generate_glossary())
    
    elements.append(create_section_header("Avertissements et Divulgations"))
    elements.append(create_formatted_paragraph(generate_disclaimer(), 'Normal'))

    # Génération du PDF
    doc.build(elements, onFirstPage=add_page_number, onLaterPages=add_page_number)
    pdf = buffer.getvalue()
    buffer.close()

    # Encodage du PDF en base64
    pdf_base64 = base64.b64encode(pdf).decode('utf-8')

    end_time = time.time()
    total_execution_time = end_time - start_time
    print(f"Temps total d'exécution: {total_execution_time:.2f} secondes")

    return {"report": pdf_base64}

@timing_decorator
def create_title_page(title, subtitle, date):
    """
    Crée une page de titre pour le rapport.

    Parameters:
    title (str): Titre du rapport.
    subtitle (str): Sous-titre du rapport.
    date (str): Date du rapport.

    Returns:
    list: Une liste d'éléments à ajouter à la page de titre.
    """
    elements = []
    styles = getSampleStyleSheet()
    
    # Ajouter le logo
    logo = Image("/app/logo.jpg", width=2*inch, height=1*inch)
    elements.append(logo)
    
    elements.append(Spacer(1, 1*inch))
    
    title_style = ParagraphStyle(name='Title', parent=styles['Title'], fontSize=24, alignment=1)
    elements.append(Paragraph(title, title_style))
    
    elements.append(Spacer(1, 0.5*inch))
    
    subtitle_style = ParagraphStyle(name='Subtitle', parent=styles['Normal'], fontSize=18, alignment=1)
    elements.append(Paragraph(subtitle, subtitle_style))
    
    elements.append(Spacer(1, 0.5*inch))
    
    date_style = ParagraphStyle(name='Date', parent=styles['Normal'], fontSize=14, alignment=1)
    elements.append(Paragraph(date, date_style))
    
    elements.append(PageBreak())
    return elements

def generate_executive_summary(portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return):
    """
    Génère le résumé exécutif du rapport.
    
    Parameters:
    portfolio (dict): Informations sur le portefeuille.
    portfolio_data (dict): Données de clôture des actions.
    returns (DataFrame): Rendements quotidiens des actions.
    weights (ndarray): Poids des actions dans le portefeuille.
    weighted_returns (Series): Rendements pondérés quotidiens du portefeuille.
    total_return (float): Rendement total du portefeuille.
    annualized_return (float): Rendement annualisé du portefeuille.
    
    Returns:
    list: Éléments à ajouter au rapport.
    """
    # Calcul du score ESG
    sp500_data = get_sp500_data(
        portfolio_data[list(portfolio_data.keys())[0]].index[0],
        portfolio_data[list(portfolio_data.keys())[0]].index[-1]
    )
    
    if sp500_data.empty:
        sp500_return = 0
        sp500_volatility = 0
        sp500_sharpe = 0
    else:
        sp500_return = (sp500_data.iloc[-1] / sp500_data.iloc[0]) - 1
        sp500_volatility = sp500_data.pct_change().std() * np.sqrt(252)
        sp500_sharpe = (sp500_return - 0.02) / sp500_volatility if sp500_volatility != 0 else 0
    
    portfolio_volatility = weighted_returns.std() * np.sqrt(252)
    sharpe_ratio = (annualized_return - 0.02) / portfolio_volatility if portfolio_volatility != 0 else 0
    
    summary = (
        f"Résumé Exécutif\n"
        f"Ce rapport présente une analyse détaillée de la performance du portefeuille sur la période du "
        f"{portfolio_data[list(portfolio_data.keys())[0]].index[0].strftime('%d/%m/%Y')} au "
        f"{portfolio_data[list(portfolio_data.keys())[0]].index[-1].strftime('%d/%m/%Y')}.\n\n"
        f"Points clés :\n"
        f"• Rendement total du portefeuille : {total_return:.2%}\n"
        f"• Rendement annualisé : {annualized_return:.2%}\n"
        f"• Volatilité annualisée : {portfolio_volatility:.2%}\n"
        f"• Ratio de Sharpe : {sharpe_ratio:.2f}\n\n"
        f"Comparaison avec le S&P 500 :\n"
        f"• Rendement total S&P 500 : {sp500_return:.2%}\n"
        f"• Volatilité S&P 500 : {sp500_volatility:.2%}\n"
        f"• Ratio de Sharpe S&P 500 : {sp500_sharpe:.2f}\n\n"
        f"Le portefeuille a {'sous-performé' if total_return < sp500_return else 'sur-performé'} l'indice S&P 500 sur la période, avec un "
        f"{'risque plus élevé' if portfolio_volatility > sp500_volatility else 'risque plus faible'}."
    )
    
    elements = []
    elements.append(create_formatted_paragraph(summary, 'BodyText'))
    
    # Ajout de l'analyse générée par l'IA
    try:
        additional_analysis = generate_ai_content(f"""
        En vous basant sur les données suivantes :
        - Rendement total du portefeuille : {total_return:.2%}
        - Rendement annualisé : {annualized_return:.2%}
        - Volatilité du portefeuille : {portfolio_volatility:.2%}
        - Ratio de Sharpe du portefeuille : {sharpe_ratio:.2f}
        - Rendement total S&P 500 : {sp500_return:.2%}
        - Volatilité S&P 500 : {sp500_volatility:.2%}
        - Ratio de Sharpe S&P 500 : {sp500_sharpe:.2f}
        
        Fournissez une analyse succincte de la performance du portefeuille. Incluez :
        1. Une évaluation générale de la performance du portefeuille par rapport au marché.
        2. Les principaux facteurs qui ont contribué à cette performance.
        3. Les points forts et les points faibles du portefeuille.
        4. Des recommandations préliminaires pour l'amélioration du portefeuille.
        """)
    except Exception as e:
        print(f"Erreur lors de la génération de l'analyse AI: {e}")
        additional_analysis = "Analyse supplémentaire indisponible."
    
    elements.append(create_formatted_paragraph(additional_analysis, 'BodyText'))
    
    return elements


def generate_portfolio_overview(portfolio, portfolio_data, returns, weights):
    """
    Génère la vue d'ensemble du portefeuille.

    Parameters:
    portfolio (dict): Informations sur le portefeuille.
    portfolio_data (dict): Données de clôture des actions.
    returns (DataFrame): Rendements quotidiens des actions.
    weights (ndarray): Poids des actions dans le portefeuille.

    Returns:
    list: Une liste d'éléments à ajouter à la section de la vue d'ensemble du portefeuille.
    """
    elements = []
    
    data = [['Titre', 'Poids', 'Prix d\'entrée', 'Prix actuel', 'Rendement']]
    for stock, weight in zip(portfolio['stocks'], weights):
        symbol = stock['symbol']
        entry_price = float(stock['entry_price'])
        current_price = pd.DataFrame(portfolio_data)[symbol].iloc[-1]
        stock_return = (current_price / entry_price - 1)
        data.append([symbol, f"{weight:.2%}", f"{entry_price:.2f} €", f"{current_price:.2f} €", f"{stock_return:.2%}"])
    
    table = Table(data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    elements.append(Spacer(1, 12))
    
    fig = go.Figure()
    portfolio_value = (pd.DataFrame(portfolio_data) * weights).sum(axis=1)
    fig.add_trace(go.Scatter(x=pd.DataFrame(portfolio_data).index, y=portfolio_value,
                             mode='lines', name='Valeur du Portefeuille'))
    fig.update_layout(title="Évolution de la Valeur du Portefeuille",
                      xaxis_title="Date", yaxis_title="Valeur")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    return elements

def generate_glossary():
    """
    Génère le glossaire du rapport.

    Returns:
    list: Une liste d'éléments à ajouter à la section du glossaire.
    """
    elements = []
    styles = getSampleStyleSheet()
    body_style = styles['BodyText']
    
    glossary_terms = [
        ("Rendement Total", "Le gain ou la perte sur un investissement exprimé en pourcentage du capital investi."),
        ("Volatilité", "Une mesure de la variation des prix d'un actif financier."),
        ("Ratio de Sharpe", "Une mesure du rendement ajusté au risque, calculée en divisant le rendement excédentaire par l'écart-type des rendements."),
        ("VaR (Value at Risk)", "Une mesure statistique de la perte potentielle maximale d'un portefeuille sur une période donnée pour un niveau de confiance spécifié."),
        ("Drawdown", "La baisse en pourcentage d'un investissement par rapport à son pic le plus récent.")
    ]
    
    for term, definition in glossary_terms:
        elements.append(Paragraph(f"<b>{term}</b>: {definition}", body_style))
        elements.append(Spacer(1, 6))
    
    return elements

def generate_disclaimer():
    """
    Génère les avertissements et divulgations du rapport.

    Returns:
    str: Le texte des avertissements et divulgations.
    """
    disclaimer_text = """
    Ce rapport est fourni à titre informatif uniquement et ne constitue pas un conseil en investissement. 
    Les performances passées ne garantissent pas les résultats futurs. La valeur des investissements peut fluctuer 
    et les investisseurs peuvent perdre une partie ou la totalité de leur capital investi. Avant de prendre toute 
    décision d'investissement, il est recommandé de consulter un conseiller financier professionnel. 
    Les informations contenues dans ce rapport sont considérées comme fiables, mais leur exactitude et leur 
    exhaustivité ne peuvent être garanties. Ce rapport ne doit pas être reproduit, distribué ou publié sans 
    autorisation préalable.
    """
    return disclaimer_text.strip()

def generate_stock_performance_comparison(portfolio_data, weights):
    """
    Génère la comparaison de performance des actions.

    Parameters:
    portfolio_data (dict): Données de clôture des actions.
    weights (ndarray): Poids des actions dans le portefeuille.

    Returns:
    list: Une liste d'éléments à ajouter à la section de la comparaison de performance des actions.
    """
    elements = []
    
    stock_returns = pd.DataFrame(portfolio_data).pct_change().mean() * 252
    
    stock_performance = list(zip(stock_returns.index, stock_returns.values * 100))
    stock_performance.sort(key=lambda x: x[1], reverse=True)
    
    fig = go.Figure([go.Bar(
        x=[s[0] for s in stock_performance],
        y=[s[1] for s in stock_performance],
        text=[f"{s[1]:.2%}%" for s in stock_performance],
        textposition='auto',
    )])
    fig.update_layout(title="Comparaison de Performance des Actions",
                      xaxis_title="Action", yaxis_title="Rendement Annualisé (%)")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    explanation = generate_ai_content(f"""
    Analysez la performance relative des actions du portefeuille en vous basant sur les données suivantes:
    {', '.join([f"{s[0]}: {s[1]:.2f}%" for s in stock_performance])}
    Identifiez les meilleures et les pires performances, et suggérez des explications possibles pour ces écarts de performance.
    Considérez également l'impact de la pondération de chaque action (poids: {weights}) sur la performance globale du portefeuille.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_contribution_to_return(portfolio, portfolio_data, returns, weights):
    """
    Génère la contribution de chaque action au rendement total du portefeuille.

    Parameters:
    portfolio (dict): Informations sur le portefeuille.
    portfolio_data (dict): Données de clôture des actions.
    returns (DataFrame): Rendements quotidiens des actions.
    weights (ndarray): Poids des actions dans le portefeuille.

    Returns:
    list: Une liste d'éléments à ajouter à la section de la contribution de chaque action au rendement total du portefeuille.
    """
    elements = []
    
    total_return = (pd.DataFrame(portfolio_data).iloc[-1] / pd.DataFrame(portfolio_data).iloc[0] - 1).sum()
    contributions = []
    for stock, weight in zip(portfolio['stocks'], weights):
        symbol = stock['symbol']
        stock_return = pd.DataFrame(portfolio_data)[symbol].iloc[-1] / pd.DataFrame(portfolio_data)[symbol].iloc[0] - 1
        contribution = stock_return * weight
        contributions.append((symbol, contribution, contribution / total_return))
    
    contributions.sort(key=lambda x: x[1], reverse=True)
    
    data = [['Action', 'Contribution', '% du Total']]
    for symbol, contribution, percentage in contributions:
        data.append([symbol, f"{contribution:.2%}", f"{percentage:.2%}"])
    
    table = Table(data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    
    explanation = generate_ai_content(f"""
    Analysez la contribution de chaque action au rendement total du portefeuille en vous basant sur les données suivantes:
    {', '.join([f"{s[0]}: {s[1]:.2%}%" for s in contributions])}
    Identifiez les actions qui ont le plus contribué positivement et négativement, et expliquez l'impact de la pondération sur ces contributions.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements


def get_sp500_returns(start_date, end_date):
    """
    Récupère les rendements quotidiens de l'indice S&P 500 sur une période donnée.

    Parameters:
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    Series: Rendements quotidiens de l'indice S&P 500.
    """
    sp500 = yf.Ticker("^GSPC")
    sp500_data = sp500.history(start=start_date, end=end_date)['Close']
    return sp500_data.pct_change().dropna()

def get_sp500_data(start_date, end_date):
    """
    Récupère les données de clôture de l'indice S&P 500 sur une période donnée.

    Parameters:
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    Series: Données de clôture de l'indice S&P 500.
    """
    sp500 = yf.Ticker("^GSPC")
    sp500_data = sp500.history(start=start_date, end=end_date)['Close']
    return sp500_data

def generate_additional_ratios_table(portfolio, portfolio_data, returns, weights, start_date, end_date):
    """
    Génère un tableau de ratios supplémentaires du portefeuille.

    Parameters:
    portfolio (dict): Informations sur le portefeuille.
    portfolio_data (dict): Données de clôture des actions.
    returns (DataFrame): Rendements quotidiens des actions.
    weights (ndarray): Poids des actions dans le portefeuille.
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    list: Une liste d'éléments à ajouter à la section des ratios supplémentaires du portefeuille.
    """
    elements = []
    
    # Recalculer les rendements du portefeuille
    df = pd.DataFrame(portfolio_data)
    portfolio_returns = df.pct_change().dropna()
    portfolio_returns = (portfolio_returns * weights).sum(axis=1)

    # Obtenir les rendements du S&P 500
    benchmark_returns = get_sp500_returns(start_date, end_date)

    # S'assurer que les deux séries ont le même index
    common_dates = portfolio_returns.index.intersection(benchmark_returns.index)
    portfolio_returns = portfolio_returns.loc[common_dates]
    benchmark_returns = benchmark_returns.loc[common_dates]

    risk_free_rate = 0.02 / 252  # Taux journalier
    
    excess_returns = portfolio_returns - risk_free_rate
    benchmark_excess_returns = benchmark_returns - risk_free_rate
    
    beta = np.cov(portfolio_returns, benchmark_returns)[0][1] / np.var(benchmark_returns)
    alpha = np.mean(excess_returns) - beta * np.mean(benchmark_excess_returns)
    tracking_error = np.std(portfolio_returns - benchmark_returns) * np.sqrt(252)
    information_ratio = (np.mean(portfolio_returns - benchmark_returns) * 252) / tracking_error
    downside_returns = np.minimum(excess_returns - np.mean(excess_returns), 0)
    sortino_ratio = np.mean(excess_returns) / (np.std(downside_returns) * np.sqrt(252))
    
    ratios = {
        "Beta": beta,
        "Alpha": alpha * 252,  # Annualisé
        "Tracking Error": tracking_error,
        "Information Ratio": information_ratio,
        "Sortino Ratio": sortino_ratio
    }
    
    data = [['Ratio', 'Valeur']]
    for ratio, value in ratios.items():
        data.append([ratio, f"{value:.4f}"])
    
    table = Table(data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    
    explanation = generate_ai_content(f"""
    Analysez les ratios supplémentaires du portefeuille en vous basant sur les données suivantes:
    Beta: {ratios['Beta']:.4f}
    Alpha: {ratios['Alpha']:.4f}
    Tracking Error: {ratios['Tracking Error']:.4f}
    Information Ratio: {ratios['Information Ratio']:.4f}
    Sortino Ratio: {ratios['Sortino Ratio']:.4f}
    Expliquez ce que chaque ratio signifie et comment interpréter ces valeurs dans le contexte de ce portefeuille.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def analyze_portfolio_correlation(returns):
    """
    Analyse la corrélation des actions du portefeuille.

    Parameters:
    returns (DataFrame): Rendements quotidiens des actions.

    Returns:
    tuple: (correlation_matrix, explained_variance_ratio)
        - correlation_matrix (DataFrame): Matrice de corrélation des actions.
        - explained_variance_ratio (ndarray): Proportion de la variance expliquée par chaque composante principale.
    """
    correlation_matrix = returns.corr()
    pca = PCA()
    pca.fit(returns)
    explained_variance_ratio = pca.explained_variance_ratio_
    return correlation_matrix, explained_variance_ratio

def generate_correlation_heatmap(portfolio_data):
    """
    Génère un heatmap de corrélation des actions du portefeuille.

    Parameters:
    portfolio_data (dict): Données de clôture des actions.

    Returns:
    list: Une liste d'éléments à ajouter à la section du heatmap de corrélation des actions du portefeuille.
    """
    elements = []
    
    returns = pd.DataFrame(portfolio_data).pct_change().dropna()
    correlation_matrix, explained_variance_ratio = analyze_portfolio_correlation(returns)
    
    # Créer le heatmap de corrélation
    fig = go.Figure(data=go.Heatmap(
        z=correlation_matrix.values,
        x=correlation_matrix.index,
        y=correlation_matrix.columns,
        colorscale='RdBu',
        zmin=-1, zmax=1
    ))
    fig.update_layout(title="Matrice de Corrélation des Actions")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=500))
    
    # Trouver les paires les plus et moins corrélées
    corr_values = correlation_matrix.values[np.triu_indices_from(correlation_matrix.values, 1)]
    max_corr = np.max(corr_values)
    min_corr = np.min(corr_values)
    max_corr_pair = np.unravel_index(np.argmax(correlation_matrix.values), correlation_matrix.shape)
    min_corr_pair = np.unravel_index(np.argmin(correlation_matrix.values), correlation_matrix.shape)
    
    # Calculer la corrélation moyenne
    avg_correlation = np.mean(corr_values)
    
    # Calculer le nombre de composantes principales nécessaires pour expliquer 80% de la variance
    num_components = np.sum(np.cumsum(explained_variance_ratio) <= 0.8) + 1
    
    explanation = generate_ai_content(f"""
    Analysez la matrice de corrélation des actions du portefeuille en vous basant sur les informations suivantes :
    
    1. Corrélation moyenne du portefeuille : {avg_correlation:.2f}
    2. Paire d'actions la plus corrélée : {correlation_matrix.index[max_corr_pair[0]]} et {correlation_matrix.index[max_corr_pair[1]]} (corrélation de {max_corr:.2f})
    3. Paire d'actions la moins corrélée : {correlation_matrix.index[min_corr_pair[0]]} et {correlation_matrix.index[min_corr_pair[1]]} (corr��lation de {min_corr:.2f})
    4. Nombre de composantes principales nécessaires pour expliquer 80% de la variance : {num_components}
    5. Proportion de la variance expliquée par la première composante principale : {explained_variance_ratio[0]:.2%}
    
    Basez votre analyse sur ces points :
    1. Interprétez la corrélation moyenne du portefeuille. Est-elle élevée, moyenne ou faible ?
    2. Discutez des implications des paires d'actions les plus et les moins corrélées.
    3. Analysez l'impact de ces corrélations sur la diversification du portefeuille.
    4. Commentez sur le nombre de composantes principales nécessaires pour expliquer 80% de la variance. Qu'est-ce que cela nous dit sur la diversification du portefeuille ?
    5. Interprétez la proportion de variance expliquée par la première composante principale. Qu'est-ce que cela implique pour le risque du portefeuille ?
    6. Suggérez des moyens spécifiques d'améliorer la diversification du portefeuille en fonction de ces corrélations et de l'analyse en composantes principales.
    7. Discutez des limites potentielles de cette analyse de corrélation (par exemple, la non-linéarité des relations entre les actifs).
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_performance_analysis(portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return, start_date, end_date):
    """
    Génère l'analyse de performance du portefeuille.

    Parameters:
    portfolio (dict): Informations sur le portefeuille.
    portfolio_data (dict): Données de clôture des actions.
    returns (DataFrame): Rendements quotidiens des actions.
    weights (ndarray): Poids des actions dans le portefeuille.
    weighted_returns (Series): Rendements pondérés quotidiens du portefeuille.
    total_return (float): Rendement total du portefeuille.
    annualized_return (float): Rendement annualisé du portefeuille.
    start_date (str): Date de début au format 'YYYY-MM-DD'.
    end_date (str): Date de fin au format 'YYYY-MM-DD'.

    Returns:
    list: Une liste d'éléments à ajouter à la section de l'analyse de performance du portefeuille.
    """
    elements = []
    
    volatility = weighted_returns.std() * np.sqrt(252)
    cumulative_returns = (1 + weighted_returns).cumprod()
    risk_free_rate = 0.02  # 2% par exemple
    sharpe_ratio = (annualized_return - risk_free_rate) / volatility
    
    sp500_data = get_sp500_data(start_date, end_date)
    sp500_returns = sp500_data.pct_change().dropna()
    sp500_cumulative_returns = (1 + sp500_returns).cumprod()
    sp500_total_return = sp500_cumulative_returns.iloc[-1] - 1
    sp500_annualized_return = (1 + sp500_total_return) ** (252 / len(sp500_returns)) - 1
    sp500_volatility = sp500_returns.std() * np.sqrt(252)
    sp500_sharpe_ratio = (sp500_annualized_return - 0.02) / sp500_volatility
    
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=cumulative_returns.index, y=cumulative_returns,
                             mode='lines', name='Portefeuille'))
    fig.add_trace(go.Scatter(x=sp500_cumulative_returns.index, y=sp500_cumulative_returns,
                             mode='lines', name='S&P 500'))
    fig.update_layout(title="Comparaison des Rendements Cumulés",
                      xaxis_title="Date", yaxis_title="Rendement Cumulé")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))

    performance_comparison = [
        ['Métrique', 'Portefeuille', 'S&P 500'],
        ['Rendement Total', f"{total_return:.2%}", f"{sp500_total_return:.2%}"],
        ['Rendement Annualisé', f"{annualized_return:.2%}", f"{sp500_annualized_return:.2%}"],
        ['Volatilité Annualisée', f"{volatility:.2%}", f"{sp500_volatility:.2%}"],
        ['Ratio de Sharpe', f"{sharpe_ratio:.2f}", f"{sp500_sharpe_ratio:.2f}"]
    ]
    
    table = Table(performance_comparison)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)

    explanation = generate_ai_content(f"""
    Expliquez la performance du portefeuille par rapport au S&P 500 en vous basant sur les données suivantes:
    - Rendement total du portefeuille: {total_return:.2%}
    - Rendement total du S&P 500: {sp500_total_return:.2%}
    - Volatilité du portefeuille: {volatility:.2%}
    - Volatilité du S&P 500: {sp500_volatility:.2%}
    - Ratio de Sharpe du portefeuille: {sharpe_ratio:.2f}
    - Ratio de Sharpe du S&P 500: {sp500_sharpe_ratio:.2f}
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    # Graphique des rendements cumulés
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=cumulative_returns.index, y=cumulative_returns,
                             mode='lines', name='Rendements Cumulés'))
    fig.update_layout(title="Rendements Cumulés du Portefeuille",
                      xaxis_title="Date", yaxis_title="Rendement Cumulé")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    return elements

def generate_risk_analysis(portfolio, portfolio_data, returns, weights, weighted_returns):
    elements = []
    
    var_95 = np.percentile(weighted_returns, 5)
    cvar_95 = weighted_returns[weighted_returns <= var_95].mean()
    cumulative_returns = (1 + weighted_returns).cumprod()
    max_drawdown = (cumulative_returns.cummax() - cumulative_returns).max()
    
    risk_data = [
        ['Métrique', 'Valeur'],
        ['VaR (95%)', f"{var_95:.2%}"],
        ['CVaR (95%)', f"{cvar_95:.2%}"],
        ['Drawdown Maximum', f"{max_drawdown:.2%}"]
    ]
    
    table = Table(risk_data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    elements.append(Spacer(1, 12))
    
    fig = ff.create_distplot([weighted_returns], ['Rendements du Portefeuille'], show_hist=False, show_rug=False)
    fig.update_layout(title="Distribution des Rendements du Portefeuille",
                      xaxis_title="Rendement", yaxis_title="Densité")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    return elements

def generate_sector_allocation(portfolio, portfolio_data, returns, weights):
    elements = []

    async def get_sectors():
        urls = [f"https://query2.finance.yahoo.com/v10/finance/quoteSummary/{stock['symbol']}?modules=assetProfile" for stock in portfolio['stocks']]
        results = await get_multiple_stock_data(urls)
        sectors = {}
        for stock, result in zip(portfolio['stocks'], results):
            sector = result.get('quoteSummary', {}).get('result', [{}])[0].get('assetProfile', {}).get('sector', 'Unknown')
            sectors[stock['symbol']] = sector
        return sectors

    # Obtenir les secteurs pour chaque action
    sectors = asyncio.run(get_sectors())
    
    # Calculer l'allocation sectorielle
    sector_weights = {}
    for stock, weight in zip(portfolio['stocks'], weights):
        sector = sectors[stock['symbol']]
        sector_weights[sector] = sector_weights.get(sector, 0) + weight
    
    # Créer le graphique
    fig = px.pie(values=list(sector_weights.values()), names=list(sector_weights.keys()),
                 title="Allocation Sectorielle du Portefeuille")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    explanation = generate_ai_content(f"""
    Analysez l'allocation sectorielle du portefeuille en vous basant sur les données suivantes :
    {', '.join([f"{sector}: {weight:.2%}" for sector, weight in sector_weights.items()])}
    Discutez de la diversification sectorielle du portefeuille.
    Identifiez les secteurs surpondérés et sous-pondérés par rapport à un indice de référence (comme le S&P 500).
    Commentez sur les risques et opportunités potentiels liés à cette allocation sectorielle.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_best_worst_performers(portfolio, portfolio_data, returns, weights):
    elements = []
    
    df = pd.DataFrame(portfolio_data)
    stock_returns = df.pct_change().mean() * 252  # rendements annualisés
    stock_volatility = df.pct_change().std() * np.sqrt(252)  # volatilité annualisée
    stock_sharpe = stock_returns / stock_volatility  # ratio de Sharpe

    performance_data = []
    for stock, weight in zip(portfolio['stocks'], weights):
        symbol = stock['symbol']
        performance_data.append({
            'symbol': symbol,
            'return': stock_returns[symbol],
            'volatility': stock_volatility[symbol],
            'sharpe': stock_sharpe[symbol],
            'weight': weight
        })

    performance_data.sort(key=lambda x: x['return'], reverse=True)
    
    best_worst_data = [['Rang', 'Titre', 'Rendement', 'Volatilité', 'Sharpe', 'Poids']]
    for i in range(min(3, len(performance_data))):
        best = performance_data[i]
        worst = performance_data[-(i+1)]
        best_worst_data.append([
            f"Top {i+1}",
            best['symbol'],
            f"{best['return']:.2%}",
            f"{best['volatility']:.2%}",
            f"{best['sharpe']:.2f}",
            f"{best['weight']:.2%}"
        ])
        best_worst_data.append([
            f"Bottom {i+1}",
            worst['symbol'],
            f"{worst['return']:.2%}",
            f"{worst['volatility']:.2%}",
            f"{worst['sharpe']:.2f}",
            f"{worst['weight']:.2%}"
        ])
    
    table = Table(best_worst_data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    
    explanation = generate_ai_content(f"""
    Analysez les meilleures et pires performances du portefeuille en vous basant sur les données suivantes:
    Meilleures performances:
    {', '.join([f"{p['symbol']}: rendement {p['return']:.2%}, volatilité {p['volatility']:.2%}, Sharpe {p['sharpe']:.2f}" for p in performance_data[:3]])}
    Pires performances:
    {', '.join([f"{p['symbol']}: rendement {p['return']:.2%}, volatilité {p['volatility']:.2%}, Sharpe {p['sharpe']:.2f}" for p in performance_data[-3:]])}
    Discutez des facteurs qui pourraient expliquer ces performances. Commentez sur l'impact de ces performances sur l'ensemble du portefeuille, en tenant compte des pondérations.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_dividend_table(portfolio):
    elements = []
    
    dividend_data = [['Titre', 'Rendement du Dividende', 'Fréquence', 'Dernier Dividende']]
    for stock in portfolio['stocks']:
        ticker = get_stock_info(stock['symbol'])
        info = ticker.info
        dividend_yield = info.get('dividendYield', 0)
        dividend_rate = info.get('dividendRate', 0)
        
        dividend_data.append([
            stock['symbol'],
            f"{dividend_yield:.2%}" if dividend_yield else "N/A",
            info.get('dividendFrequency', 'N/A'),
            f"${dividend_rate:.2f}" if dividend_rate else "N/A"
        ])
    
    table = Table(dividend_data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    
    explanation = generate_ai_content(f"""
    Analysez la politique de dividendes des actions du portefeuille en vous basant sur les données du tableau.
    Identifiez les actions avec les rendements de dividendes les plus élevés et les plus bas.
    Discutez de l'impact des dividendes sur le rendement total du portefeuille.
    Commentez sur la durabilité des dividendes en fonction des taux de distribution (si disponibles).
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_monte_carlo_simulation(portfolio, portfolio_data, returns, weights, weighted_returns):
    elements = []
    
    # Paramètres de la simulation
    num_simulations = 1000
    num_days = 252  # un an de trading
    
    # Calcul des paramètres de la distribution log-normale
    mu = np.mean(weighted_returns)
    sigma = np.std(weighted_returns)
    
    # Simulation
    simulations = np.zeros((num_simulations, num_days))
    for i in range(num_simulations):
        simulations[i] = np.random.lognormal(mu, sigma, num_days)
    simulations = np.cumprod(simulations, axis=1)
    
    # Calcul des percentiles
    final_values = simulations[:, -1]
    percentiles = np.percentile(final_values, [5, 50, 95])
    
    # Graphique
    fig = go.Figure()
    for i in range(100):  # Tracer 100 simulations pour la lisibilité
        fig.add_trace(go.Scatter(y=simulations[i], mode='lines', opacity=0.1,
                                 line=dict(color='blue'), showlegend=False))
    fig.update_layout(title="Simulation Monte Carlo de la Valeur du Portefeuille",
                      xaxis_title="Jours", yaxis_title="Valeur du Portefeuille")
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    # Tableau des résultats
    results_data = [
        ['Percentile', 'Valeur Finale'],
        ['5%', f"{percentiles[0]:.2f}"],
        ['50%', f"{percentiles[1]:.2f}"],
        ['95%', f"{percentiles[2]:.2f}"]
    ]
    table = Table(results_data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    
    explanation = generate_ai_content(f"""
    Interprétez les résultats de la simulation Monte Carlo pour le portefeuille.
    Les valeurs finales du portefeuille après un an de trading sont :
    - 5% de chance d'être inférieure à {percentiles[0]:.2f}
    - 50% de chance d'être supérieure à {percentiles[1]:.2f}
    - 5% de chance d'être supérieure à {percentiles[2]:.2f}
    Discutez des implications de ces résultats pour l'investisseur.
    Commentez sur la dispersion des résultats et ce qu'elle signifie en termes de risque pour le portefeuille.
    Expliquez comment cette simulation Monte Carlo utilisant une distribution log-normale diffère d'un simple rééchantillonnage et pourquoi elle pourrait être plus appropriée pour modéliser les rendements futurs.
    """)
    elements.append(create_formatted_paragraph(explanation, 'BodyText'))
    
    return elements

def generate_stress_tests(portfolio, portfolio_data, returns, weights, weighted_returns):
    elements = []
    
    # Définition des scénarios de stress avec impacts différenciés par secteur
    scenarios = {
        "Crise financière": {
            "Financials": -0.40,
            "Technology": -0.25,
            "Consumer Discretionary": -0.30,
            "default": -0.20
        },
        "Récession économique": {
            "Consumer Discretionary": -0.35,
            "Industrials": -0.30,
            "Materials": -0.25,
            "default": -0.15
        },
        "Pandémie": {
            "Health Care": 0.10,
            "Consumer Staples": 0.05,
            "Energy": -0.30,
            "default": -0.10
        },
        "Guerre commerciale": {
            "Industrials": -0.20,
            "Technology": -0.15,
            "Materials": -0.25,
            "default": -0.10
        },
        "Catastrophe naturelle": {
            "Energy": -0.20,
            "Utilities": -0.15,
            "Real Estate": -0.10,
            "default": -0.05
        }
    }
    
    # Obtenir les secteurs pour chaque action
    stock_sectors = {}
    for stock in portfolio['stocks']:
        ticker = get_stock_info(stock['symbol'])
        info = ticker.info
        stock_sectors[stock['symbol']] = info.get('sector', 'Unknown')
    
    # Calcul de l'impact des scénarios sur le portefeuille
    portfolio_impacts = {}
    for scenario, sector_impacts in scenarios.items():
        impact = 0
        for stock, weight in zip(portfolio['stocks'], weights):
            sector = stock_sectors[stock['symbol']]
            sector_impact = sector_impacts.get(sector, sector_impacts['default'])
            impact += sector_impact * weight
        portfolio_impacts[scenario] = impact
    
    # Création du texte d'analyse
    analysis = f"""
    Tests de Stress du Portefeuille

    Les scénarios suivants ont été simulés pour évaluer la résilience du portefeuille :
    {', '.join([f"{scenario}: {impact:.2%}" for scenario, impact in portfolio_impacts.items()])}

    Ces tests de stress montrent comment le portefeuille pourrait réagir dans différentes conditions de marché extrêmes,
    en tenant compte des impacts différenciés sur les secteurs. Il est important de noter que ces scénarios sont
    hypothétiques et ne prédisent pas nécessairement des événements futurs.
    """
    
    elements.append(create_formatted_paragraph(analysis, 'BodyText'))
    
    # Création d'un graphique pour visualiser les impacts
    fig = go.Figure(data=[go.Bar(
        x=list(scenarios.keys()),
        y=[impact * 100 for impact in portfolio_impacts.values()],
        text=[f"{impact:.2%}" for impact in portfolio_impacts.values()],
        textposition='auto',
    )])
    fig.update_layout(
        title="Impact des Scénarios de Stress sur le Portefeuille",
        xaxis_title="Scénarios",
        yaxis_title="Impact sur la Valeur du Portefeuille (%)",
        yaxis_tickformat='.2%'
    )
    
    img_buffer = BytesIO()
    fig.write_image(img_buffer, format='png')
    img_buffer.seek(0)
    elements.append(Image(img_buffer, width=500, height=300))
    
    return elements

def add_page_number(canvas, doc):
    canvas.saveState()
    canvas.setFont('Helvetica', 9)
    page_number_text = "%d" % (doc.page)
    canvas.drawCentredString(4.25 * inch, 0.75 * inch, page_number_text)
    canvas.restoreState()

def create_section_header(text, level=1):
    style = getSampleStyleSheet()[f'Heading{level}']
    return Paragraph(text, style)

def generate_recommendations(portfolio, portfolio_data, returns, weights, weighted_returns, total_return, annualized_return):
    elements = []
    
    portfolio_volatility = weighted_returns.std() * np.sqrt(252)
    
    risk_free_rate = 0.02  # Taux sans risque de 2%
    sharpe_ratio = (annualized_return - risk_free_rate) / portfolio_volatility

    # Comparer avec le S&P 500
    sp500_data = get_sp500_data(portfolio_data[list(portfolio_data.keys())[0]].index[0], portfolio_data[list(portfolio_data.keys())[0]].index[-1])
    sp500_return = (sp500_data.iloc[-1] / sp500_data.iloc[0]) - 1
    sp500_volatility = sp500_data.pct_change().std() * np.sqrt(252)

    # Calculer la corrélation moyenne entre les actions
    correlation_matrix = returns.corr()
    avg_correlation = correlation_matrix.values[np.triu_indices_from(correlation_matrix.values,1)].mean()

    # Calculer les ratios P/E et la croissance des bénéfices pour chaque action
    pe_ratios = {}
    earnings_growth = {}
    for stock in portfolio['stocks']:
        ticker = get_stock_info(stock['symbol'])
        info = ticker.info
        pe_ratios[stock['symbol']] = info.get('trailingPE', 'N/A')
        earnings_growth[stock['symbol']] = info.get('earningsQuarterlyGrowth', 'N/A')

    # Générer des recommandations basées sur ces métriques
    recommendations_text = generate_ai_content(f"""
    En vous basant sur les données suivantes du portefeuille :
    - Rendement total : {total_return:.2%}
    - Rendement annualisé : {annualized_return:.2%}
    - Volatilité : {portfolio_volatility:.2%}
    - Ratio de Sharpe : {sharpe_ratio:.2f}
    - Rendement du S&P 500 : {sp500_return:.2%}
    - Volatilité du S&P 500 : {sp500_volatility:.2%}
    - Corrélation moyenne entre les actions : {avg_correlation:.2f}
    - Ratios P/E des actions : {pe_ratios}
    - Croissance des bénéfices des actions : {earnings_growth}

    Générez une liste de 5 à 7 recommandations spécifiques pour améliorer la performance et réduire le risque du portefeuille. 
    Tenez compte des éléments suivants dans vos recommandations :
    1. La performance relative par rapport au S&P 500
    2. Le niveau de risque du portefeuille
    3. La diversification actuelle du portefeuille
    4. Les tendances récentes du marché
    5. Les opportunités potentielles dans différents secteurs
    6. Les ratios P/E des actions par rapport à leurs moyennes historiques ou sectorielles
    7. Les tendances de croissance des bénéfices des actions

    Pour chaque recommandation, fournissez une brève explication de son raisonnement et de son impact potentiel.
    Assurez-vous d'inclure des recommandations spécifiques sur les actions à acheter, vendre ou conserver, en vous basant sur leur valorisation et leur croissance.
    """)

    elements.append(create_section_header("Recommandations", level=2))
    elements.append(create_formatted_paragraph(recommendations_text, 'BodyText'))

    return elements

def generate_future_outlook(portfolio, portfolio_data, returns, weights):
    elements = []
    
    # Calculer quelques métriques supplémentaires pour l'analyse
    sector_allocation = calculate_sector_allocation(portfolio)
    stock_performance = calculate_stock_performance(portfolio_data)
    
    # Calculer la volatilité du portefeuille
    portfolio_returns = (returns * weights).sum(axis=1)
    portfolio_volatility = portfolio_returns.std() * np.sqrt(252)
    
    # Calculer le rendement total du portefeuille
    total_return = (pd.DataFrame(portfolio_data).iloc[-1] / pd.DataFrame(portfolio_data).iloc[0] - 1).sum()
    
    # Obtenir des données macroéconomiques actuelles
    current_date = datetime.now()
    start_date = current_date - timedelta(days=30)  # Données du dernier mois
    
    try:
        inflation = get_fred_data('CPIAUCSL', start_date, current_date)
        unemployment = get_fred_data('UNRATE', start_date, current_date)
        gdp_growth = get_fred_data('GDP', start_date, current_date)
        
        latest_inflation = inflation.iloc[-1]['CPIAUCSL']
        latest_unemployment = unemployment.iloc[-1]['UNRATE']
        latest_gdp_growth = gdp_growth.iloc[-1]['GDP']
    except Exception as e:
        print(f"Erreur lors de la récupération des données macroéconomiques : {e}")
        latest_inflation = "N/A"
        latest_unemployment = "N/A"
        latest_gdp_growth = "N/A"
    
    # Générer le texte des perspectives futures
    outlook_text = generate_ai_content(f"""
    En vous basant sur les données suivantes :
    - Allocation sectorielle : {sector_allocation}
    - Performance des actions : {stock_performance}
    - Rendement total du portefeuille : {total_return:.2%}
    - Volatilité du portefeuille : {portfolio_volatility:.2%}
    - Inflation actuelle : {latest_inflation}
    - Taux de chômage actuel : {latest_unemployment}%
    - Croissance du PIB actuelle : {latest_gdp_growth}%

    Générez des perspectives futures pour le portefeuille. Incluez :
    1. Une analyse des tendances économiques et de marché qui pourraient affecter le portefeuille, en tenant compte des données macroéconomiques actuelles.
    2. Des prévisions pour les secteurs représentés dans le portefeuille, en considérant leur performance récente et les conditions économiques actuelles.
    3. Des recommandations pour des ajustements potentiels du portefeuille, basées sur les perspectives sectorielles et macroéconomiques.
    4. Une discussion sur les risques potentiels et les opportunités à venir, en tenant compte de l'environnement économique actuel.
    5. Des suggestions pour diversifier davantage le portefeuille si nécessaire, en considérant les secteurs qui pourraient bien performer dans le contexte économique actuel.
    """)
    
    elements.append(create_formatted_paragraph("Perspectives Futures", 'Heading2'))
    elements.append(create_formatted_paragraph(outlook_text, 'BodyText'))
    
    return elements


def calculate_sector_allocation(portfolio):
    sector_weights = {}
    sector_cache = {}
    for stock in portfolio['stocks']:
        if stock['symbol'] not in sector_cache:
            ticker = get_stock_info(stock['symbol'])
            info = ticker.info
            sector_cache[stock['symbol']] = info.get('sector', 'Unknown')
        sector = sector_cache[stock['symbol']]
        weight = float(stock['weight']) / 100
        sector_weights[sector] = sector_weights.get(sector, 0) + weight
    return sector_weights

def calculate_stock_performance(portfolio_data):
    df = pd.DataFrame(portfolio_data)
    return {symbol: (data.iloc[-1] / data.iloc[0] - 1) for symbol, data in df.items()}

>>>

./compile.py :
<<<
import os
import argparse
import os
import base64


def lire_fichier(chemin):
    try:
        with open(chemin, 'r', encoding='utf-8') as fichier:
            return fichier.read()
    except Exception as e:
        return f"Erreur lors de la lecture du fichier : {str(e)}"

def compiler_fichiers(dossier_racine, extensions, dossiers_exclus, fichier_sortie):
    with open(fichier_sortie, 'w', encoding='utf-8') as sortie:
        for dossier_actuel, sous_dossiers, fichiers in os.walk(dossier_racine):
            # Exclure les dossiers spécifiés
            sous_dossiers[:] = [d for d in sous_dossiers if d not in dossiers_exclus]
            
            for fichier in fichiers:
                if any(fichier.endswith(ext) for ext in extensions):
                    chemin_complet = os.path.join(dossier_actuel, fichier)
                    contenu = lire_fichier(chemin_complet)
                    
                    sortie.write(f"{chemin_complet} :\n")
                    sortie.write("<<<\n")
                    sortie.write(contenu)
                    sortie.write("\n>>>\n\n")

def main():
    parser = argparse.ArgumentParser(description="Compiler des fichiers de code dans un fichier texte.")
    parser.add_argument("dossier", help="Le dossier racine à parcourir")
    parser.add_argument("--extensions", nargs='+', default=['.py'], help="Les extensions de fichier à inclure")
    parser.add_argument("--exclure", nargs='+', default=['node_modules'], help="Les dossiers à exclure")
    parser.add_argument("--sortie", default="compilation_code.txt", help="Le nom du fichier de sortie")
    
    args = parser.parse_args()
    
    compiler_fichiers(args.dossier, args.extensions, args.exclure, args.sortie)
    print(f"Compilation terminée. Résultat dans {args.sortie}")

if __name__ == "__main__":
    main()
>>>

./agent_j.py :
<<<
import yfinance as yf
from datetime import datetime, timedelta
import openai

class HistoricalDataAnalysisAgent:
    def __init__(self):
        self.client = openai.OpenAI()

    def analyze_previous_day(self, ticker, start_date=None, end_date=None):
        if not start_date:
            start_date = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        if not end_date:
            end_date = datetime.now().strftime('%Y-%m-%d')

        try:
            stock = yf.Ticker(ticker)
            hist = stock.history(start=start_date, end=end_date)
            
            if hist.empty:
                return f"Pas de données disponibles pour {ticker} entre {start_date} et {end_date}."

            # Préparation des données pour l'analyse
            data = {
                "ticker": ticker,
                "start_date": start_date,
                "end_date": end_date,
                "open_price": hist['Open'].iloc[0],
                "close_price": hist['Close'].iloc[-1],
                "high": hist['High'].max(),
                "low": hist['Low'].min(),
                "volume": hist['Volume'].mean(),
                "return": ((hist['Close'].iloc[-1] / hist['Open'].iloc[0]) - 1) * 100
            }

            # Utilisation de ChatGPT pour l'analyse
            response = self.client.chat.completions.create(
                model="gpt-4o-2024-08-06",
                messages=[
                    {"role": "system", "content": "Vous êtes un analyste financier. Analysez les données boursières suivantes et fournissez des insights."},
                    {"role": "user", "content": f"Analysez les données suivantes pour {ticker} du {start_date} au {end_date}:\n{data}"}
                ],
                temperature=0.5,
                max_tokens=800
            )

            return response.choices[0].message.content.strip()

        except Exception as e:
            return f"Erreur lors de l'analyse des données historiques pour {ticker}: {str(e)}"

historical_data_agent = HistoricalDataAnalysisAgent()
>>>

./copilote_central.py :
<<<
#!/usr/local/bin/python3
# -*- coding: utf-8 -*-
from flask import Flask, request, jsonify
from flask_cors import CORS, cross_origin
import sqlite3
from threading import Thread
import time
import json
from openai import OpenAI
import anthropic
from groq import Groq
import deepl
from PyPDF2 import PdfReader
import uuid
import random
from datetime import datetime, timedelta
import io
from io import BytesIO
# from dotenv import load_dotenv
import os
import re
import bcrypt
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity, set_access_cookies
import pandas as pd
import numpy as np
import yfinance as yf
from typing import List

from agent_a import document_agent
from agent_b import sentiment_agent
from agent_c import financial_modeling_agent
from agent_d import portfolio_optimization_agent
from agent_e import risk_management_agent
from agent_f import reporting_agent
from agent_g import compliance_agent
from agent_h import market_sentiment_agent
from agent_i import investment_recommendation_agent
from agent_j import historical_data_agent
from agent_k import user_profile_agent
from selecteur_modele_ia import SelecteurModeleIA
from generateur_report import generate_report

# Load environment variables
# load_dotenv()

app = Flask(__name__)
CORS(app, resources={r"/*": {
    "origins": ["https://www.finpilot.one", "http://localhost:3000"],
    "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    "allow_headers": ["Content-Type", "Authorization"],
    "supports_credentials": True
}})

@app.after_request
def add_security_headers(response):
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'  # Restriction plus sûre
    response.headers['Content-Security-Policy'] = "default-src 'self';"  # Politique de sécurité plus restrictive
    return response


# @app.route('/<path:path>', methods=['OPTIONS'])
# def handle_options(path):
#     response = jsonify({'status': 'OK'})
#     response.headers.add('Access-Control-Allow-Origin', 'https://www.finpilot.one')
#     response.headers.add('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS')
#     response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
#     return response

# @app.before_request
# def log_request_info():
#     print(f"Headers: {request.headers}")
#     print(f"Body: {request.get_data()}")

# Initialize OpenAI and Anthropic clients
openai_client = OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
anthropic_client = anthropic.Anthropic(api_key=os.getenv('ANTHROPIC_API_KEY'))
groq_client = Groq(api_key=os.environ.get("GROQ_API_KEY"))
DEEPL_API_KEY = os.environ.get('DEEPL_API_KEY')
translator = deepl.Translator(DEEPL_API_KEY)

# Configuration de la base de données SQLite
DATABASE = '/litefs/copilot-db.db'

def get_db():
    return sqlite3.connect(DATABASE)

# Configure JWT
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY')
jwt = JWTManager(app)

# Augmentez la durée de validité du token JWT
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = timedelta(days=30)
functions = [
    {
        "type": "function",
        "function": {
            "name": "analyze_documents",
            "description": "Analyser et résumer des documents financiers",
            "parameters": {
                "type": "object",
                "properties": {
                    "text": {
                        "type": "string",
                        "description": "Le texte à analyser"
                    }
                },
                "required": ["text"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "analyze_sentiment",
            "description": "Analyser le sentiment des actualités financières",
            "parameters": {
                "type": "object",
                "properties": {
                    "company": {
                        "type": "string",
                        "description": "L'entreprise pour laquelle analyser le sentiment"
                    }
                },
                "required": ["company"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "model_financials",
            "description": "Effectuer une modélisation financière pour une action donnée",
            "parameters": {
                "type": "object",
                "properties": {
                    "ticker": {
                        "type": "string",
                        "description": "Le symbole boursier de l'action"
                    }
                },
                "required": ["ticker"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "optimize_portfolio",
            "description": "Optimiser un portefeuille d'actions",
            "parameters": {
                "type": "object",
                "properties": {
                    "tickers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Liste des symboles boursiers des actions"
                    }
                },
                "required": ["tickers"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "manage_risks",
            "description": "Analyser les risques d'un portefeuille",
            "parameters": {
                "type": "object",
                "properties": {
                    "tickers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Liste des symboles boursiers des actions"
                    },
                    "portfolio_value": {
                        "type": "number",
                        "description": "Valeur totale du portefeuille"
                    }
                },
                "required": ["tickers", "portfolio_value"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "generate_report",
            "description": "Générer un rapport financier",
            "parameters": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "object",
                        "description": "Données financières à inclure dans le rapport"
                    }
                },
                "required": ["data"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "check_compliance",
            "description": "Vérifier la conformité du portefeuille avec les réglementations",
            "parameters": {
                "type": "object",
                "properties": {
                    "portfolio_data": {
                        "type": "object",
                        "description": "Données du portefeuille à vérifier pour la conformité"
                    }
                },
                "required": ["portfolio_data"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "analyze_market_sentiment",
            "description": "Analyser le sentiment du marché pour une action donnée",
            "parameters": {
                "type": "object",
                "properties": {
                    "ticker": {
                        "type": "string",
                        "description": "Le symbole boursier de l'action"
                    }
                },
                "required": ["ticker"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_investment_recommendation",
            "description": "Obtenir des recommandations d'investissement basées sur un portefeuille et un profil de risque",
            "parameters": {
                "type": "object",
                "properties": {
                    "portfolio": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Liste des symboles boursiers dans le portefeuille"
                    },
                    "risk_profile": {
                        "type": "string",
                        "description": "Le profil de risque de l'investisseur (ex: conservateur, modéré, agressif)"
                    }
                },
                "required": ["portfolio", "risk_profile"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "analyze_previous_day_data",
            "description": "Analyser les données de trading du jour précédent pour une action donnée",
            "parameters": {
                "type": "object",
                "properties": {
                    "ticker": {
                        "type": "string",
                        "description": "Le symbole boursier de l'action"
                    }
                },
                "required": ["ticker"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "analyze_user_profile",
            "description": "Analyser le profil d'investissement de l'utilisateur basé sur ses interactions et l'historique de son portefeuille",
            "parameters": {
                "type": "object",
                "properties": {
                    "user_interactions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Liste des interactions récentes de l'utilisateur"
                    },
                    "portfolio_history": {
                        "type": "object",
                        "description": "Valeurs historiques du portefeuille"
                    }
                },
                "required": ["user_interactions", "portfolio_history"]
            }
        }
    }
]

assistant = openai_client.beta.assistants.create(
    name="Finance Copilot",
    instructions="Vous êtes un assistant financier. Utilisez les fonctions fournies pour analyser des documents, évaluer le sentiment, effectuer des modélisations financières, optimiser des portefeuilles, gérer les risques, générer des rapports et vérifier la conformité.",
    model="gpt-4o-2024-08-06",
    tools=functions
)


ai_selector = SelecteurModeleIA()

# Variable globale pour stocker les résultats des appels de fonction
financial_data = {}

def get_value(x):
    return x.iloc[0] if isinstance(x, pd.Series) else x

def hash_password(password):
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

def check_password(password, hashed):
    return bcrypt.checkpw(password.encode('utf-8'), hashed)

def get_user_by_username(username):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
        user = cursor.fetchone()
        return user if user else None

@app.route('/register', methods=['POST'])
def register():
    print(f"Requête d'inscription reçue : {request.json}")
    data = request.json
    username = data.get('username')
    password = data.get('password')
    
    if not username or not password:
        return jsonify({"erreur": "Le nom d'utilisateur et le mot de passe sont requis"}), 400
    
    hashed_password = hash_password(password)
    
    try:
        with sqlite3.connect(DATABASE) as conn:
            conn.execute("INSERT INTO users (username, password) VALUES (?, ?)",
                         (username, hashed_password))
        return jsonify({"message": "Utilisateur enregistré avec succès"}), 201
    except sqlite3.IntegrityError:
        return jsonify({"erreur": "Le nom d'utilisateur existe déjà"}), 400

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    username = data.get('username')
    password = data.get('password')
    
    user = get_user_by_username(username)
    if user and check_password(password, user[2]):
        access_token = create_access_token(identity=user[0])
        response = jsonify(access_token=access_token)
        set_access_cookies(response, access_token)
        return response, 200
    else:
        return jsonify({"erreur": "Nom d'utilisateur ou mot de passe invalide"}), 401
    
    # Fonction pour enregistrer le chat
def save_chat_message(user_id, role, content):
    try:
        print(f"Tentative de sauvegarde du message pour l'utilisateur {user_id}")
        print(f"Role : {role}")
        print(f"Contenu : {content}")
        
        if content is None:
            content = ""
        elif hasattr(content, 'content'):
            content = content.content
        elif isinstance(content, (dict, list)):
            content = json.dumps(content)
        else:
            content = str(content)
        
        if not content.strip():
            print("Le contenu du message est vide, abandon de la sauvegarde")
            return
        
        with sqlite3.connect(DATABASE) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO chat_history (user_id, role, content, timestamp)
                VALUES (?, ?, ?, datetime('now'))
            """, (user_id, role, content))
            conn.commit()
        print("Message sauvegardé avec succès")
    except Exception as e:
        app.logger.error(f"Erreur lors de la sauvegarde du message: {str(e)}", exc_info=True)
        raise

# Fonction pour récupérer l'historique des chats
def get_chat_history(user_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT role, content, timestamp FROM chat_history
            WHERE user_id = ?
            ORDER BY timestamp DESC
        """, (user_id,))
        results = cursor.fetchall()
        return [
            {
                "role": role,
                "content": json.loads(content) if content.startswith('{') else content,
                "timestamp": timestamp
            }
            for role, content, timestamp in results
        ]

class ConversationManager:
    def __init__(self):
        self.conversations = {}

    def start_conversation(self):
        conversation_id = str(uuid.uuid4())
        self.conversations[conversation_id] = {
            "messages": [],
            "last_updated": datetime.now()
        }
        return conversation_id

    def add_message(self, conversation_id, message):
        if conversation_id in self.conversations:
            self.conversations[conversation_id]["messages"].append(message)
            self.conversations[conversation_id]["last_updated"] = datetime.now()

    def get_messages(self, conversation_id):
        return self.conversations.get(conversation_id, {}).get("messages", [])

    def clean_old_conversations(self, max_age_hours=24):
        now = datetime.now()
        for conv_id, conv_data in list(self.conversations.items()):
            if now - conv_data["last_updated"] > timedelta(hours=max_age_hours):
                del self.conversations[conv_id]

conversation_manager = ConversationManager()

def parse_portfolio(message):
    portfolio = {}
    pattern = r'(\d+(?:\.\d+)?)\s*(?:de|d\')\s*(\w+)'
    matches = re.findall(pattern, message.lower())
    for allocation, stock in matches:
        # Vérifiez si le symbole est valide (vous devrez implémenter cette fonction)
        if is_valid_symbol(stock):
            portfolio[stock.upper()] = float(allocation)
        else:
            return {"erreur": f"Symbole d'action invalide: {stock}"}
    return portfolio if portfolio else {"erreur": "Aucune information de portefeuille valide trouvée"}

def is_valid_symbol(symbol):
    # Implémentez cette fonction pour vérifier si le symbole est valide
    # Par exemple, vous pouvez avoir une liste de symboles valides ou faire une requête à une API
    valid_symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'FB', 'NVDA', 'JPM', 'JNJ', 'V']
    return symbol.upper() in valid_symbols


def execute_function(function_name, arguments, user_message):
    global financial_data
    print(f"Executing function: {function_name}")
    print(f"Arguments received: {arguments}")
    try:
        if function_name == "check_compliance":
            portfolio = parse_portfolio(user_message)
            if portfolio:
                return compliance_agent.check_compliance({"portfolio_data": portfolio})
            else:
                return {
                    "erreur": "missing_data",
                    "message": "Informations sur le portefeuille manquantes. Veuillez fournir les détails du portefeuille."
                }
        elif function_name == "analyze_documents":
            return document_agent.analyser(arguments.get("text", ""))
        elif function_name == "analyze_sentiment":
            return sentiment_agent.analyze(arguments.get("company", ""))
        elif function_name == "model_financials":
            ticker = arguments.get("ticker", "")
            result = financial_modeling_agent.analyze(ticker)
            financial_data[ticker] = result
            return result
        elif function_name == "optimize_portfolio":
            result = portfolio_optimization_agent.optimize(arguments.get("tickers", []))
            financial_data['portfolio_optimization'] = result
            return result
        elif function_name == "manage_risks":
            return risk_management_agent.analyze(
                arguments.get("tickers", []), 
                arguments.get("portfolio_value", 100000)
            )
        elif function_name == "generate_report":
            return reporting_agent.generate_report(financial_data)
        elif function_name == "analyze_market_sentiment":
            data = request.json
            ticker = data.get('ticker')
            sentiment = market_sentiment_agent.analyze_sentiment(ticker)
            return jsonify({"sentiment": sentiment})
        elif function_name == "get_investment_recommendation":
            return investment_recommendation_agent.get_recommendation(
                arguments.get("portfolio"),
                arguments.get("risk_profile")
            )
        elif function_name == "analyze_previous_day_data":
            return historical_data_agent.analyze_previous_day(arguments.get("ticker"))
        elif function_name == "analyze_user_profile":
            return user_profile_agent.analyze_user_profile(
                arguments.get("user_id"),
                arguments.get("portfolio"),
                arguments.get("chat_history")
            )
        else:
            return {"erreur": f"Fonction {function_name} introuvable"}
    except KeyError as e:
        return {
            "erreur": "missing_data",
            "message": f"Données manquantes : {str(e)}. Pouvez-vous fournir plus d'informations ?"
        }
    except Exception as e:
        return {
            "erreur": "execution_error",
            "message": f"Une erreur s'est produite lors de l'exécution de {function_name}: {str(e)}"
        }

def init_db():
    with sqlite3.connect(DATABASE) as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS users
                        (id INTEGER PRIMARY KEY AUTOINCREMENT,
                         username TEXT UNIQUE NOT NULL,
                         password TEXT NOT NULL)''')
        conn.execute('''CREATE TABLE IF NOT EXISTS portfolios
                        (id INTEGER PRIMARY KEY AUTOINCREMENT,
                         user_id INTEGER,
                         name TEXT NOT NULL,
                         data TEXT NOT NULL)''')
        conn.execute('''CREATE TABLE IF NOT EXISTS portfolio (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        name TEXT,
                        symbol TEXT,
                        weight REAL,
                        entry_price REAL,
                        FOREIGN KEY (user_id) REFERENCES users(id))''')
        conn.execute('''CREATE TABLE IF NOT EXISTS user_settings (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER NOT NULL,
                        setting_name TEXT NOT NULL,
                        setting_value TEXT,
                        UNIQUE(user_id, setting_name))''')
        conn.execute('''CREATE TABLE IF NOT EXISTS tasks (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        task_type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        result TEXT
                    )''')
        conn.execute('''CREATE TABLE IF NOT EXISTS chat_history
                        (id INTEGER PRIMARY KEY AUTOINCREMENT,
                         user_id INTEGER NOT NULL,
                         role TEXT NOT NULL,
                         content TEXT NOT NULL,
                         timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')

@app.route('/clear_chat', methods=['POST'])
@jwt_required()
def clear_chat():
    user_id = get_jwt_identity()
    try:
        with sqlite3.connect(DATABASE) as conn:
            conn.execute("DELETE FROM chat_history WHERE user_id = ?", (user_id,))
        return jsonify({"message": "Historique de chat effacé avec succès"}), 200
    except Exception as e:
        app.logger.error(f"Erreur lors de l'effacement de l'historique de chat: {str(e)}")
        return jsonify({"erreur": "Échec de l'effacement de l'historique de chat"}), 500

def get_user_setting(user_id, setting_name, default_value=None):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT setting_value FROM user_settings WHERE user_id = ? AND setting_name = ?", (user_id, setting_name))
        result = cursor.fetchone()
        if result:
            try:
                return json.loads(result[0])
            except json.JSONDecodeError:
                return result[0]
    return default_value

def set_user_setting(user_id, setting_name, setting_value):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        if isinstance(setting_value, (list, dict)):
            setting_value = json.dumps(setting_value)
        cursor.execute("""
            INSERT OR REPLACE INTO user_settings (user_id, setting_name, setting_value)
            VALUES (?, ?, ?)
        """, (user_id, setting_name, setting_value))
        conn.commit()
    print(f"Paramètre '{setting_name}' sauvegardé pour l'utilisateur {user_id}: {setting_value}")


def save_portfolio(user_id, name, stocks):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        # Supprimer l'ancien portfolio
        cursor.execute("DELETE FROM portfolio WHERE user_id = ?", (user_id,))
        # Insérer le nouveau portfolio
        for stock in stocks:
            cursor.execute("""
                INSERT INTO portfolio (user_id, name, symbol, weight, entry_price)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, name, stock['symbol'], stock['weight'], stock['entry_price']))  # Changé 'entryPrice' en 'entry_price'
        conn.commit()

def get_portfolio(user_id, name=None):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        if name:
            cursor.execute("SELECT * FROM portfolio WHERE user_id = ? AND name = ?", (user_id, name))
        else:
            cursor.execute("SELECT * FROM portfolio WHERE user_id = ?", (user_id,))
        portfolio = cursor.fetchall()
    return [{"symbol": row[3], "weight": row[4], "entry_price": row[5]} for row in portfolio]

class Agents:
    @staticmethod
    def analyze_documents(data):
        text = data.get('text', '')
        return document_agent.analyser(text)

    @staticmethod
    def analyze_sentiment(data):
        company = data.get('company', '')
        return sentiment_agent.analyze(company)

    @staticmethod
    def model_financials(data):
        ticker = data.get('ticker', '')
        return financial_modeling_agent.analyze(ticker)

    @staticmethod
    def optimize_portfolio(data):
        tickers = data.get('tickers', [])
        return portfolio_optimization_agent.optimize(tickers)

    @staticmethod
    def manage_risks(data):
        tickers = data.get('tickers', [])
        portfolio_value = data.get('portfolio_value', 100000)
        return risk_management_agent.analyze(tickers, portfolio_value)

    @staticmethod
    def generate_report(data):
        return reporting_agent.generate_report(data)

    @staticmethod
    def check_compliance(data):
        return compliance_agent.check_compliance(data)
    
def structure_data(data):
    client = openai_client
    response = client.chat.completions.create(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": "Vous êtes un assistant chargé de structurer des données financières."},
            {"role": "user", "content": f"Veuillez structurer les données suivantes en JSON : {data}"}
        ],
        response_format={"type": "json_object"}
    )
    return json.loads(response.choices[0].message.content)

def generate_verbose_response(result, function_name):
    client = openai_client
    response = client.chat.completions.create(
        model="gpt-4o-2024-08-06",
        messages=[
            {"role": "system", "content": "Vous êtes un assistant financier expert. Expliquez les résultats de manière détaillée et compréhensible."},
            {"role": "user", "content": f"Voici les résultats de la fonction {function_name}: {result}. Veuillez les expliquer de manière détaillée."}
        ]
    )
    return response.choices[0].message.content

def get_function_info(function_name):
    function_info = {
        "optimize_portfolio": {
            "default_value": 10000,
            "description": "Cette fonction optimise votre portefeuille. La valeur par défaut du portefeuille est de 10 000 $."
        },
        "analyze_documents": {
            "default_value": None,
            "description": "Cette fonction analyse et résume des documents financiers."
        },
        "analyze_sentiment": {
            "default_value": None,
            "description": "Cette fonction analyse le sentiment du marché pour un actif donné."
        },
        "financial_modeling": {
            "default_value": None,
            "description": "Cette fonction effectue une modélisation financière pour un titre donné."
        },
        "manage_risks": {
            "default_value": 100000,
            "description": "Cette fonction analyse les risques de votre portefeuille. La valeur par défaut du portefeuille est de 100 000 $."
        },
        "generate_report": {
            "default_value": None,
            "description": "Cette fonction génère un rapport financier basé sur les données fournies."
        },
        "check_compliance": {
            "default_value": None,
            "description": "Cette fonction vérifie la conformité de votre portefeuille avec les réglementations en vigueur."
        }
    }
    return function_info.get(function_name, {"description": "Aucune information supplémentaire disponible."})

# Gestionnaire de tâches
def task_manager():
    while True:
        with sqlite3.connect(DATABASE) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT id, task_type FROM tasks WHERE status = 'pending' LIMIT 1")
            task = cursor.fetchone()
            if task:
                task_id, task_type = task
                cursor.execute("UPDATE tasks SET status = 'processing' WHERE id = ?", (task_id,))
                conn.commit()

                # Exécution de la tâche
                result = getattr(Agents, task_type)({"task_id": task_id})

                cursor.execute("UPDATE tasks SET status = 'completed', result = ? WHERE id = ?", (result, task_id))
                conn.commit()
        time.sleep(1)  # Attente d'une seconde avant de vérifier à nouveau

# Démarrage du gestionnaire de tâches en arrière-plan
Thread(target=task_manager, daemon=True).start()


@app.route('/translate_news', methods=['POST'])
@jwt_required()
def translate_news():
    data = request.json
    news = data.get('news', [])
    translated_news = []

    print(f"Données reçues pour la traduction : {news}")

    try:
        for item in news:
            if isinstance(item, dict):
                title = item.get('title', '')
                description = item.get('description') or item.get('content', '')
                content = item.get('content', '')
            elif isinstance(item, str):
                title = item
                description = ""
            else:
                app.logger.warning(f"Format d'élément de nouvelles non reconnu : {item}")
                continue

            # Traduire le titre
            translated_title = translator.translate_text(
                title,
                target_lang="FR",
                formality="less"
            )

            # Traduire ou générer la description
            if description:
                translated_description = translator.translate_text(
                    description,
                    target_lang="FR",
                    formality="less"
                )
            else:
                # Si pas de description, on utilise Llama pour générer un résumé
                llama_response = anthropic_client.completions.create(
                    model="claude-3-5-sonnet-20240620",
                    max_tokens_to_sample=200,
                    prompt=f"Générez un bref résumé en français de 200 caractères maximum pour cet article dont voici le titre : {content}"
                )
                generated_description = llama_response.completion.strip()
                
                # Traduire le résumé généré si nécessaire
                if not is_french(generated_description):
                    translated_description = translator.translate_text(
                        generated_description,
                        target_lang="FR",
                        formality="less"
                    )
                else:
                    translated_description = generated_description

            translated_news.append({
                'title': translated_title.text,
                'description': translated_description.text if isinstance(translated_description, deepl.TextResult) else translated_description
            })

        print(f"Nouvelles traduites : {translated_news}")
        return jsonify(translated_news)
    except Exception as e:
        app.logger.error(f"Erreur lors de la traduction des nouvelles : {str(e)}", exc_info=True)
        return jsonify({"erreur": "Erreur lors de la traduction des nouvelles"}), 500

def is_french(text):
    # Une fonction simple pour vérifier si le texte est déjà en français
    # Cette implémentation est basique et pourrait être améliorée
    french_words = set(['le', 'la', 'les', 'un', 'une', 'des', 'et', 'ou', 'mais', 'donc'])
    words = text.lower().split()
    return any(word in french_words for word in words)

@app.route('/submit_task', methods=['POST'])
def submit_task():
    data = request.json
    task_type = data.get('task_type')
    if task_type not in dir(Agents):
        return jsonify({"erreur": "Type de tâche invalide"}), 400

    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute("INSERT INTO tasks (task_type, status) VALUES (?, 'pending')", (task_type,))
        task_id = cursor.lastrowid
        conn.commit()

    return jsonify({"task_id": task_id, "status": "pending"})

@app.route('/task_status/<int:task_id>', methods=['GET'])
def task_status(task_id):
    with sqlite3.connect(DATABASE) as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT status, result FROM tasks WHERE id = ?", (task_id,))
        task = cursor.fetchone()

    if task:
        return jsonify({"task_id": task_id, "status": task[0], "result": task[1]})
    else:
        return jsonify({"erreur": "Tâche non trouvée"}), 404

@app.route('/portfolio_analysis', methods=['POST'])
def portfolio_analysis():
    data = request.json
    task_sequence = ['analyze_documents', 'analyze_sentiment', 'model_financials', 
                     'optimize_portfolio', 'manage_risks', 'check_compliance', 'generate_report']

    results = {}
    for task in task_sequence:
        results[task] = getattr(Agents, task)(data)

    return jsonify(results)

@app.route('/chat', methods=['POST'])
@jwt_required()
def chat():
    global financial_data
    try:
        user_id = get_jwt_identity()
        data = request.json
        user_message = data.get('message')
        conversation_id = request.json.get('conversation_id')
        use_claude = request.json.get('use_claude', False)
        
        print(f"Début de la fonction chat pour l'utilisateur {user_id}")
        print(f"Message de l'utilisateur : {user_message}")
        print(f"Conversation ID : {conversation_id}")
        print(f"Utilisation de Claude : {use_claude}")
        
        save_chat_message(user_id, 'user', user_message)
        print("Message de l'utilisateur sauvegardé")

        if not conversation_id:
            conversation_id = conversation_manager.start_conversation()
            financial_data = {}
            print(f"Nouvelle conversation créée avec ID : {conversation_id}")

        messages = conversation_manager.get_messages(conversation_id)
        messages.append({"role": "user", "content": user_message})
        print(f"Messages de la conversation : {messages}")

        claude_tools = [
            {
                "name": func["function"]["name"],
                "description": func["function"]["description"],
                "input_schema": {
                    "type": "object",
                    "properties": func["function"]["parameters"]["properties"],
                    "required": func["function"]["parameters"]["required"]
                }
            } for func in functions
        ]

        client = anthropic_client if use_claude else openai_client
        model = "claude-3-5-sonnet-20240620" if use_claude else "gpt-4o-2024-08-06"
        tools = claude_tools if use_claude else functions

        print(f"Modèle utilisé : {model}")
        print(f"Outils disponibles : {tools}")

        response = client.chat.completions.create(
            model=model,
            messages=messages,
            tools=tools,
            max_tokens=1024 if use_claude else None
        )
        print(f"Réponse brute du modèle : {response}")

        if use_claude:
            assistant_message = response.content[0]
            if assistant_message.type == 'text':
                message_content = assistant_message.text
                save_chat_message(user_id, 'assistant', message_content)
                return jsonify({"reply": message_content, "conversation_id": conversation_id})
        else:
            assistant_message = response.choices[0].message
            message_content = assistant_message.content

        if not getattr(assistant_message, 'tool_calls', None):
            conversation_manager.add_message(conversation_id, {"role": "assistant", "content": message_content})
            save_chat_message(user_id, 'assistant', message_content)
            print("Pas d'appel d'outil, retour de la réponse")
            return jsonify({"reply": message_content, "conversation_id": conversation_id})

        print("Traitement des appels d'outils")
        tool_messages = []
        for tool_call in assistant_message.tool_calls:
            function_name = tool_call.function.name
            function_args = json.loads(tool_call.function.arguments)
            
            print(f"Appel de la fonction : {function_name}")
            print(f"Arguments de la fonction : {function_args}")
            
            function_info = get_function_info(function_name)
            structured_args = structure_data(function_args)
            if function_name in ['optimize_portfolio', 'manage_risks', 'check_compliance', 'get_investment_recommendation']:
                portfolio = get_portfolio(user_id)
                if portfolio:
                    function_args['portfolio'] = portfolio
                else:
                    return jsonify({"reply": "Désolé, je n'ai pas pu accéder à votre portefeuille. Veuillez vérifier que vous en avez bien un.", "conversation_id": conversation_id})

            function_response = execute_function(function_name, structured_args, user_message)
            
            print(f"Réponse de la fonction : {function_response}")
            
            if isinstance(function_response, dict) and function_response.get("erreur") == "missing_data":
                conversation_manager.add_message(conversation_id, {"role": "assistant", "content": function_response["message"]})
                print("Données manquantes, retour de la réponse d'erreur")
                return jsonify({"reply": function_response["message"], "conversation_id": conversation_id})
            
            verbose_response = generate_verbose_response(function_response, function_name)
            verbose_response += f"\n\nInformation importante : {function_info['description']}"

            tool_messages.append({
                "role": "tool",
                "content": verbose_response,
                "tool_call_id": tool_call.id
            })
            print(f"Message de l'outil ajouté : {tool_messages[-1]}")

        messages.append({
            "role": "assistant",
            "content": None,
            "tool_calls": [
                {
                    "id": tc.id,
                    "type": "function",
                    "function": {"name": tc.function.name, "arguments": tc.function.arguments}
                } for tc in assistant_message.tool_calls
            ]
        })
        messages.extend(tool_messages)

        print("Génération de la réponse finale")
        final_response = client.chat.completions.create(
            model=model,
            messages=messages
        )
        final_message = final_response.choices[0].message
        conversation_manager.add_message(conversation_id, {"role": "assistant", "content": final_message.content})
        print(f"Message final : {final_message}")
        
        save_chat_message(user_id, 'assistant', final_message.content)
        print("Message final sauvegardé dans la base de données")
        
        return jsonify({"reply": final_message.content, "conversation_id": conversation_id})
    except Exception as e:
        app.logger.error(f"Erreur dans la route /chat: {str(e)}", exc_info=True)
        return jsonify({'erreur': 'Une erreur est survenue lors du traitement de votre demande'}), 500

@app.route('/agent/<agent_name>', methods=['POST'])
@jwt_required()
def call_agent(agent_name):
    data = request.json
    user_id = get_jwt_identity()
    portfolio = get_portfolio(user_id)
    try:
        if agent_name == "document":
            result = document_agent.analyser(data['text'])
        elif agent_name == "sentiment":
            result = sentiment_agent.analyze(data['company'])
        elif agent_name == "financial_modeling":
            result = financial_modeling_agent.analyze(data['ticker'])
        elif agent_name == "portfolio_optimization":
            result = portfolio_optimization_agent.optimize(portfolio)
        elif agent_name == "risk_management":
            result = risk_management_agent.analyze(portfolio)
        elif agent_name == "reporting":
            result = reporting_agent.generate_report(portfolio)
            return jsonify(result), 200  # Utilisez jsonify pour convertir le résultat en JSON
        elif agent_name == "compliance":
            result = compliance_agent.check_compliance(portfolio)
        elif agent_name == "market_sentiment":
            if 'summary' not in data:
                data['summary'] = "No summary provided"
            result = market_sentiment_agent.analyze_sentiment(data['ticker'], data['summary'])
        elif agent_name == "investment_recommendation":
            portfolio = data.get('portfolio', [])
            if isinstance(portfolio, dict):
                portfolio = [portfolio]
            portfolio = [stock['symbol'].upper() if isinstance(stock, dict) and 'symbol' in stock else stock.upper() for stock in portfolio]
            risk_profile = data.get('risk_profile', 'moderate')
            result = investment_recommendation_agent.get_recommendation(portfolio, risk_profile)
        elif agent_name == "historical_data_analysis":
            result = historical_data_agent.analyze_previous_day(data['ticker'])
        elif agent_name == "user_profile_analysis":
            chat_history = get_chat_history(user_id)
            result = user_profile_agent.analyze_user_profile(user_id, portfolio, chat_history)
        else:
            return jsonify({"erreur": "Agent non trouvé"}), 404
        
        # Formatage du résultat en Markdown
        formatted_result = f"""
# Résultat de l'analyse par l'agent {agent_name}

{result}

---
*Cette analyse a été générée automatiquement. Veuillez l'utiliser avec discernement.*
        """
        
        return formatted_result, 200, {'Content-Type': 'text/markdown; charset=utf-8'}
    except KeyError as e:
        app.logger.error(f"Missing required data for agent {agent_name}: {str(e)}")
        return jsonify({"erreur": f"Missing required data: {str(e)}"}), 400
    except Exception as e:
        app.logger.error(f"Error in {agent_name} agent: {str(e)}")
        return jsonify({"erreur": str(e)}), 500

@app.route('/upload_pdf', methods=['POST'])
def upload_pdf():
    if 'file' not in request.files:
        return jsonify({"erreur": "Aucun fichier n'a été fourni"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"erreur": "Aucun fichier sélectionné"}), 400
    if file and file.filename.endswith('.pdf'):
        try:
            pdf_reader = PdfReader(io.BytesIO(file.read()))
            text = ""
            for page in pdf_reader.pages:
                text += page.extract_text()
            
            # Analyse du texte extrait avec l'agent d'analyse de documents
            result = analyze_financial_report(text)
            return jsonify(result)
        except Exception as e:
            app.logger.error(f"Erreur lors de l'analyse du PDF : {str(e)}")
            return jsonify({"erreur": "Erreur lors de l'analyse du PDF"}), 500
    else:
        return jsonify({"erreur": "Type de fichier invalide"}), 400

def analyze_financial_report(text):
    try:
        client, model = anthropic_client, "claude-3-5-sonnet-20240620"
        
        response = client.messages.create(
            model=model,
            max_tokens=1000,
            system="Vous êtes un analyste financier expert. Extrayez les informations financières clés du texte donné et présentez-les de manière structurée.",
            messages=[
                {"role": "user", "content": f"Analysez ce rapport financier et extrayez les informations suivantes : chiffre d'affaires, bénéfice net, EBITDA et risques clés. Présentez les résultats au format JSON structuré comme suit : {{'chiffre_affaires': nombre, 'benefice_net': nombre, 'ebitda': nombre, 'risques': [liste de chaînes]}}. Si une information n'est pas disponible, utilisez null.\n\nRapport:\n{text}"}
            ]
        )
        
        response_text = response.content[0].text
        print(f"Réponse brute de l'API : {response_text}")
        
        # Essayez d'abord de parser le JSON directement
        try:
            result = json.loads(response_text)
        except json.JSONDecodeError:
            # Si le parsing JSON échoue, essayez d'extraire les informations manuellement
            result = extract_financial_info(response_text)
        
        print(f"Résultat de l'analyse : {result}")
        return result

    except json.JSONDecodeError as e:
        app.logger.error(f"Erreur lors de l'analyse JSON : {str(e)}")
        return {"erreur": "Erreur lors de l'analyse des données financières"}
    except Exception as e:
        app.logger.error(f"Erreur inattendue dans analyze_financial_report : {str(e)}")
        return {"erreur": "Une erreur inattendue s'est produite lors de l'analyse du rapport financier"}

def extract_financial_info(text):
    result = {
        "chiffre_affaires": None,
        "benefice_net": None,
        "ebitda": None,
        "risques": []
    }
    
    # Extraction du chiffre d'affaires
    ca_match = re.search(r"chiffre d'affaires.*?(\d+(?:,\d+)?(?:\.\d+)?)", text, re.IGNORECASE)
    if ca_match:
        result["chiffre_affaires"] = float(ca_match.group(1).replace(',', ''))
    
    # Extraction du bénéfice net
    bn_match = re.search(r"bénéfice net.*?(\d+(?:,\d+)?(?:\.\d+)?)", text, re.IGNORECASE)
    if bn_match:
        result["benefice_net"] = float(bn_match.group(1).replace(',', ''))
    
    # Extraction de l'EBITDA
    ebitda_match = re.search(r"ebitda.*?(\d+(?:,\d+)?(?:\.\d+)?)", text, re.IGNORECASE)
    if ebitda_match:
        result["ebitda"] = float(ebitda_match.group(1).replace(',', ''))
    
    # Extraction des risques
    risques_match = re.search(r"risques.*?:(.*?)(?:\n|$)", text, re.IGNORECASE | re.DOTALL)
    if risques_match:
        result["risques"] = [risk.strip() for risk in risques_match.group(1).split(',') if risk.strip()]
    
    return result

@app.route('/market_analysis', methods=['POST'])
def market_analysis():
    data = request.json
    tickers = data.get('tickers', [])
    
    results = {}
    for ticker in tickers:
        sentiment = sentiment_agent.analyze(ticker)
        financials = financial_modeling_agent.analyze(ticker)
        results[ticker] = {
            "sentiment": sentiment,
            "financials": financials
        }
    
    return jsonify(results)

@app.route('/news_impact', methods=['POST'])
def news_impact():
    data = request.json
    tickers = data.get('tickers', [])
    
    news_impacts = {}
    for ticker in tickers:
        news = sentiment_agent.get_recent_news(ticker)
        impact = sentiment_agent.analyze_news_impact(news)
        news_impacts[ticker] = impact
    
    return jsonify(news_impacts)

@app.route('/analyze_pdf', methods=['POST'])
def analyze_pdf():
    if 'file' not in request.files:
        return jsonify({"erreur": "Aucun fichier n'a été fourni"}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({"erreur": "Aucun fichier sélectionné"}), 400
    if file and file.filename.endswith('.pdf'):
        pdf_reader = PdfReader(io.BytesIO(file.read()))
        text = ""
        for page in pdf_reader.pages:
            text += page.extract_text()
        
        # Analyse du texte extrait avec l'agent d'analyse de documents
        result = document_agent.analyser_rapport_financier(text)
        
        # Convertir le résultat Pydantic en dictionnaire pour la sérialisation JSON
        result_dict = result.dict()
        
        # Ajuster la structure du résultat pour correspondre à l'ancienne structure si nécessaire
        adjusted_result = {
            "resume": result_dict["resume"],
            "metriques_cles": {
                "chiffre_affaires": result_dict["metriques_cles"]["chiffre_affaires"],
                "benefice_net": result_dict["metriques_cles"]["benefice_net"],
                "ebitda": result_dict["metriques_cles"]["ebitda"],
                "risques": result_dict["metriques_cles"]["risques"]
            }
        }
        
        return jsonify(adjusted_result)
    else:
        return jsonify({"erreur": "Type de fichier invalide"}), 400

@app.route('/settings', methods=['GET', 'POST'])
@jwt_required()
def settings():
    user_id = get_jwt_identity()
    app.logger.info(f"Requête reçue pour l'utilisateur {user_id}")
    app.logger.info(f"Méthode de la requête : {request.method}")
    app.logger.info(f"En-têtes de la requête : {request.headers}")
    
    if request.method == 'GET':
        settings = {
            'defaultPortfolioValue': get_user_setting(user_id, 'default_portfolio_value', 100000),
            'riskProfile': get_user_setting(user_id, 'risk_profile', 'moderate'),
            'preferredSectors': get_user_setting(user_id, 'preferred_sectors', []),
            'theme': get_user_setting(user_id, 'theme', 'light')
        }
        app.logger.info(f"Paramètres récupérés : {settings}")
        return jsonify(settings), 200

    elif request.method == 'POST':
        if not request.is_json:
            app.logger.error("Requête POST reçue sans Content-Type application/json")
            return jsonify({"erreur": "Content-Type must be application/json"}), 415
        
        data = request.get_json()
        app.logger.info(f"Données reçues : {data}")
        
        if not data:
            return jsonify({"erreur": "No JSON data provided"}), 400
        
        set_user_setting(user_id, 'default_portfolio_value', data.get('defaultPortfolioValue', 100000))
        set_user_setting(user_id, 'risk_profile', data.get('riskProfile', 'moderate'))
        set_user_setting(user_id, 'preferred_sectors', data.get('preferredSectors', []))
        set_user_setting(user_id, 'theme', data.get('theme', 'light'))
        
        return jsonify({"message": "Settings saved successfully"}), 200

def generate_ai_content(prompt):
    message = anthropic_client.messages.create(
        model="claude-3-5-sonnet-20240620",
        max_tokens=1000,
        messages=[
            {"role": "user", "content": prompt}
        ]
    )
    return message.content[0].text

@app.route('/portfolio', methods=['GET', 'POST'])
@jwt_required()
def portfolio():
    current_user = get_jwt_identity()
    if request.method == 'POST':
        data = request.json
        try:
            save_portfolio(current_user, data['name'], data['stocks'])
            return jsonify({"message": "Portfolio sauvegardé avec succès"}), 200
        except sqlite3.Error as e:
            print(f"Erreur SQLite lors de la sauvegarde du portfolio: {e}")
            return jsonify({"erreur": "Erreur lors de la sauvegarde du portfolio"}), 500
    elif request.method == 'GET':
        try:
            with sqlite3.connect(DATABASE) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM portfolio WHERE user_id = ?", (current_user,))
                portfolio = cursor.fetchall()
                if not portfolio:
                    return jsonify({"name": "défaut", "stocks": []})
                return jsonify({"name": "défaut", "stocks": [{"symbol": row[3], "weight": row[4], "entry_price": row[5]} for row in portfolio]})
        except Exception as e:
            return jsonify({"erreur": str(e)}), 500

@app.route('/latest_price', methods=['GET'])
def latest_price():
    symbol = request.args.get('symbol')
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(period="1d")
        if not data.empty:
            latest_price = data['Close'].iloc[-1]
            return jsonify({"symbol": symbol, "prix": float(latest_price)})
        else:
            return jsonify({"erreur": "Aucune donnée disponible"}), 404
    except Exception as e:
        app.logger.error(f"Erreur lors de la récupération du dernier prix pour {symbol}: {str(e)}")
        return jsonify({"erreur": str(e)}), 500

@app.route('/historical_prices', methods=['GET'])
def historical_prices():
    symbol = request.args.get('symbol')
    start_date = request.args.get('startDate')
    end_date = request.args.get('endDate')
    try:
        ticker = yf.Ticker(symbol)
        data = ticker.history(start=start_date, end=end_date)
        return jsonify(data.to_dict(orient='index'))
    except Exception as e:
        app.logger.error(f"Erreur lors de la récupération des prix historiques pour {symbol}: {str(e)}")
        return jsonify({"erreur": str(e)}), 500

@app.route('/news', methods=['GET'])
def get_news():
    tickers = request.args.get('tickers', '').split(',')
    tickers = [ticker.strip() for ticker in tickers if ticker.strip()]
    print(f"Tickers reçus pour les nouvelles : {tickers}")
    if not tickers:
        print("Aucun ticker fourni pour les nouvelles")
        return jsonify({"message": "Aucun ticker fourni"}), 200
    try:
        news = []
        for ticker in tickers:
            ticker_news = sentiment_agent.get_news(ticker)
            news.extend(ticker_news[:3])  # Limiter à 3 nouvelles par ticker
        return jsonify(news)
    except Exception as e:
        app.logger.error(f"Erreur lors de la récupération des nouvelles : {str(e)}")
        return jsonify({"erreur": "Service de nouvelles temporairement indisponible"}), 503

@app.route('/backtest', methods=['POST'])
@jwt_required()
def backtest():
    data = request.json
    portfolio = data.get('portfolio', {})
    start_date = data.get('start_date')
    end_date = data.get('end_date')

    if not portfolio or 'stocks' not in portfolio or not portfolio['stocks']:
        return jsonify({"erreur": "Le portfolio est vide ou invalide"}), 400

    # Télécharger les données historiques
    stocks_data = {}
    weights = {}
    for stock in portfolio['stocks']:
        symbol = stock.get('symbol')
        weight = float(stock.get('weight', 0)) / 100  # Convertir en décimal
        ticker = yf.Ticker(symbol)
        hist = ticker.history(start=start_date, end=end_date)
        if hist.empty:
            return jsonify({"erreur": f"Aucune donnée historique disponible pour {symbol}"}), 400
        stocks_data[symbol] = hist['Close']
        weights[symbol] = weight

    # Créer un DataFrame avec les prix de clôture de tous les stocks
    df = pd.DataFrame(stocks_data)

    # Calculer les rendements journaliers
    returns = df.pct_change().fillna(0)

    # Calculer les rendements pondérés du portefeuille
    portfolio_returns = (returns * pd.Series(weights)).sum(axis=1)

    # Calculer la valeur du portefeuille au fil du temps
    initial_value = 10000
    portfolio_values = (1 + portfolio_returns).cumprod() * initial_value

    # Calculer les métriques de performance
    total_return = (portfolio_values.iloc[-1] / initial_value) - 1
    days = len(returns)
    annualized_return = (1 + total_return) ** (252 / days) - 1
    portfolio_volatility = portfolio_returns.std() * np.sqrt(252)
    risk_free_rate = 0.02  # Taux sans risque supposé de 2%
    sharpe_ratio = (annualized_return - risk_free_rate) / portfolio_volatility if portfolio_volatility != 0 else 0

    results = {
        "total_return": float(total_return),
        "annualized_return": float(annualized_return),
        "volatility": float(portfolio_volatility),
        "sharpe_ratio": float(sharpe_ratio),
        "portfolio_values": portfolio_values.tolist()
    }

    return jsonify(results)

@app.route('/chat_history', methods=['GET', 'POST'])
@jwt_required()
def chat_history():
    user_id = get_jwt_identity()

    if request.method == 'GET':
        try:
            history = get_chat_history(user_id)
            return jsonify(history), 200
        except sqlite3.Error as e:
            app.logger.error(f"Erreur de base de données lors de la récupération de l'historique de chat: {str(e)}")
            return jsonify({"erreur": "Échec de la récupération de l'historique de chat"}), 500
        except Exception as e:
            app.logger.error(f"Erreur inattendue lors de la récupération de l'historique de chat: {str(e)}")
            return jsonify({"erreur": "Une erreur inattendue s'est produite"}), 500

    elif request.method == 'POST':
        data = request.json
        if not data or not isinstance(data, dict) or 'role' not in data or 'content' not in data:
            return jsonify({"erreur": "Format de données invalide. Attendu 'role' et 'content'"}), 400
        
        try:
            print(data)
            save_chat_message(user_id, data['role'], data['content'])
            return jsonify({"message": "Message de chat enregistré avec succès"}), 200
        except sqlite3.Error as e:
            app.logger.error(f"Erreur de base de données lors de l'enregistrement du message de chat: {str(e)}")
            return jsonify({"erreur": "Échec de l'enregistrement du message de chat"}), 500
        except Exception as e:
            app.logger.error(f"Erreur inattendue lors de l'enregistrement du message de chat: {str(e)}")
            return jsonify({"erreur": "Une erreur inattendue s'est produite"}), 500

@app.route('/compare_portfolios', methods=['POST'])
@jwt_required()
def compare_portfolios():
    data = request.json
    print("Données reçues dans compare_portfolios:", data)
    
    portfolio = data['portfolio']
    benchmark = data['benchmark']
    start_date = data.get('start_date')
    end_date = data.get('end_date')

    print("Type de portfolio:", type(portfolio))
    print("Contenu du portfolio:", portfolio)

    # Vérifier si le portfolio est vide
    if not portfolio:
        return jsonify({"erreur": "Le portfolio est vide"}), 400

    # Vérifier et ajuster les dates
    if not start_date:
        start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')
    if not end_date:
        end_date = datetime.now().strftime('%Y-%m-%d')

    # Télécharger les données historiques du portefeuille
    portfolio_data = {}
    portfolio_weights = {}

    # Vérifier si portfolio est une liste ou un dictionnaire
    if isinstance(portfolio, list):
        stocks = portfolio
    elif isinstance(portfolio, dict) and 'stocks' in portfolio:
        stocks = portfolio['stocks']
    else:
        return jsonify({"erreur": "Structure de portfolio invalide"}), 400

    for stock in stocks:
        try:
            symbol = stock['symbol']
            weight = float(stock['weight']) / 100  # Convertir le poids en décimal
            ticker = yf.Ticker(symbol)
            hist = ticker.history(start=start_date, end=end_date)
            portfolio_data[symbol] = hist['Close']
            portfolio_weights[symbol] = weight
        except Exception as e:
            print(f"Erreur lors du traitement de l'action {stock}: {str(e)}")
            return jsonify({"erreur": f"Erreur lors du traitement de l'action {stock}: {str(e)}"}), 400

    # Vérifier si des données ont été récupérées
    if not portfolio_data:
        return jsonify({"erreur": "Aucune donnée n'a pu être récupérée pour le portfolio donné"}), 400

    # Calculer les rendements du portefeuille
    portfolio_returns = pd.DataFrame(portfolio_data).pct_change().dropna()
    weighted_returns = portfolio_returns.mul(pd.Series(portfolio_weights))
    portfolio_return = weighted_returns.sum(axis=1)

    # Calculer le rendement total et annualisé du portefeuille
    total_return = (1 + portfolio_return).prod() - 1
    days = len(portfolio_return)
    annualized_return = (1 + total_return) ** (252 / days) - 1

    # Télécharger les données historiques du benchmark
    benchmark_ticker = yf.Ticker(benchmark)
    benchmark_data = benchmark_ticker.history(start=start_date, end=end_date)
    benchmark_returns = benchmark_data['Close'].pct_change().dropna()

    # Calculer le rendement total et annualisé du benchmark
    benchmark_total_return = (1 + benchmark_returns).prod() - 1
    benchmark_annualized_return = (1 + benchmark_total_return) ** (252 / len(benchmark_returns)) - 1

    # Calculer les volatilités
    portfolio_volatility = portfolio_return.std() * np.sqrt(252)
    benchmark_volatility = benchmark_returns.std() * np.sqrt(252)

    # Calculer les ratios de Sharpe (en supposant un taux sans risque de 2%)
    risk_free_rate = 0.02
    portfolio_sharpe = (annualized_return - risk_free_rate) / portfolio_volatility
    benchmark_sharpe = (benchmark_annualized_return - risk_free_rate) / benchmark_volatility

    # Calculer la performance cumulée
    portfolio_cumulative = (1 + portfolio_return).cumprod()
    benchmark_cumulative = (1 + benchmark_returns).cumprod()

    results = {
        "portfolio_return": float(annualized_return),
        "benchmark_return": float(benchmark_annualized_return),
        "portfolio_volatility": float(portfolio_volatility),
        "benchmark_volatility": float(benchmark_volatility),
        "portfolio_sharpe": float(portfolio_sharpe),
        "benchmark_sharpe": float(benchmark_sharpe),
        "portfolio_cumulative": portfolio_cumulative.tolist(),
        "benchmark_cumulative": benchmark_cumulative.tolist()
    }

    return jsonify(results)


@app.route('/simulate_scenario', methods=['POST'])
@jwt_required()
def simulate_scenario():
    data = request.json
    portfolio = data['portfolio']
    scenario = data['scenario']
    
    scenarios = {
        "market_crash": {"mean": -0.001, "volatility": 0.03},
        "bull_market": {"mean": 0.0008, "volatility": 0.015},
        "high_inflation": {"mean": 0.0003, "volatility": 0.02},
    }
    
    if scenario not in scenarios:
        return jsonify({"erreur": "Scénario invalide"}), 400
    
    scenario_params = scenarios[scenario]
    
    initial_value = 10000
    days = 252  # 1 year of trading days
    
    daily_returns = np.random.normal(scenario_params['mean'], scenario_params['volatility'], days)
    cumulative_returns = (1 + daily_returns).cumprod()
    portfolio_values = initial_value * cumulative_returns
    final_value = portfolio_values[-1]
    
    results = {
        "scenario": scenario,
        "initial_value": initial_value,
        "final_value": final_value,
        "total_return": (final_value / initial_value) - 1,
        "daily_returns": daily_returns.tolist(),
        "portfolio_values": portfolio_values.tolist()
    }
    
    return jsonify(results)


@app.route('/generate_report', methods=['POST'])
@jwt_required()
def generate_report_route():
    data = request.json
    return generate_report(data)

@app.route('/update_portfolio_value', methods=['POST'])
@jwt_required()
def update_portfolio_value():
    data = request.json
    user_id = get_jwt_identity()
    new_value = data.get('portfolio_value')
    
    if not new_value:
        return jsonify({"erreur": "La valeur du portfolio est requise"}), 400
    
    try:
        with sqlite3.connect(DATABASE) as conn:
            conn.execute("INSERT OR REPLACE INTO user_settings (user_id, setting_name, setting_value) VALUES (?, 'portfolio_value', ?)",
                         (user_id, str(new_value)))
        return jsonify({"message": "Valeur du portfolio mise à jour avec succès"}), 200
    except Exception as e:
        return jsonify({"erreur": str(e)}), 500

@app.route('/get_portfolio_value', methods=['GET'])
@jwt_required()
def get_portfolio_value():
    user_id = get_jwt_identity()
    
    try:
        with sqlite3.connect(DATABASE) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT setting_value FROM user_settings WHERE user_id = ? AND setting_name = 'portfolio_value'", (user_id,))
            result = cursor.fetchone()
            if result:
                return jsonify({"portfolio_value": float(result[0])}), 200
            else:
                return jsonify({"portfolio_value": 100000}), 200  # Valeur par défaut
    except Exception as e:
        return jsonify({"erreur": str(e)}), 500

if __name__ == '__main__':
    init_db()
    app.run(debug=True)
>>>

./import json.py :
<<<
import json
import ast

def clean_and_parse_json(content):
    # Nettoyer le contenu
    content = content.strip()
    if content.startswith("[") and content.endswith("]"):
        content = content[1:-1]  # Enlever les crochets extérieurs

    # Utiliser ast.literal_eval pour évaluer en toute sécurité le contenu
    try:
        parsed_objects = ast.literal_eval("[" + content + "]")
        return parsed_objects
    except (SyntaxError, ValueError) as e:
        print(f"Erreur lors du parsing: {str(e)}")
        return []

def main():
    # Charger les données JSON
    with open('./articles.json', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Nettoyer et parser le contenu
    articles = clean_and_parse_json(content)
    
    # Écrire le résultat dans un nouveau fichier JSON
    with open('formatted_articles.json', 'w', encoding='utf-8') as f:
        json.dump(articles, f, ensure_ascii=False, indent=2)

    print(f"Nombre d'articles traités : {len(articles)}")

if __name__ == "__main__":
    main()
>>>

./selecteur_modele_ia.py :
<<<

from openai import OpenAI
import anthropic

class SelecteurModeleIA:
    def __init__(self):
        self.client_openai = OpenAI()
        self.client_anthropic = anthropic.Anthropic()

    def selectionner_modele(self, complexite_tache):
        if complexite_tache == "simple":
            return self.client_openai, "gpt-4o-mini"
        elif complexite_tache == "complexe":
            return self.client_anthropic, "claude-3-5-sonnet"
        else:
            return self.client_openai, "gpt-4o-2024-08-06"
>>>

./agent_a.py :
<<<
from pydantic import BaseModel
from typing import List
import openai
import os
import json


openai.api_key = os.getenv('OPENAI_API_KEY') 

class PhraseCle(BaseModel):
    phrase: str

class AnalyseDocument(BaseModel):
    mots_cles: List[str]
    phrases_cles: List[PhraseCle]
    resume: str

class MetriquesFinancieres(BaseModel):
    chiffre_affaires: float
    benefice_net: float
    ebitda: float
    risques: List[str]

class RapportFinancier(BaseModel):
    resume: str
    metriques_cles: MetriquesFinancieres

class AgentAnalyseDocument:
    def __init__(self):
        self.client = openai.OpenAI()

    def analyser(self, texte: str) -> AnalyseDocument:
        try:
            completion = self.client.chat.completions.create(
                model="gpt-4o-2024-08-06",
                messages=[
                    {"role": "system", "content": "Vous êtes un expert en analyse de documents. Votre tâche est d'extraire les informations clés du texte fourni en français. Veuillez fournir : 1) Une liste de mots-clés pertinents, 2) Une liste de phrases clés qui capturent les idées principales, et 3) Un résumé concis mais complet du document."},
                    {"role": "user", "content": texte}
                ],
                response_format={"type": "json_object"},
                temperature=0.5,
                max_tokens=1000
            )
            
            resultat = json.loads(completion.choices[0].message.content)
            return AnalyseDocument(**resultat)
        except Exception as e:
            print(f"Erreur dans analyser: {str(e)}")
            return AnalyseDocument(mots_cles=[], phrases_cles=[], resume="Une erreur s'est produite lors de l'analyse.")

    def analyser_rapport_financier(self, texte: str) -> RapportFinancier:
        try:
            completion = self.client.chat.completions.create(
                model="gpt-4o-2024-08-06",
                messages=[
                    {"role": "system", "content": "En tant qu'analyste financier expert, votre tâche est d'extraire et d'analyser les informations financières clés du rapport fourni en français. Veuillez fournir : 1) Un résumé concis des points financiers principaux, 2) Les métriques clés suivantes : chiffre d'affaires, bénéfice net, EBITDA, et une liste des risques financiers potentiels identifiés. Assurez-vous que votre analyse est précise et pertinente pour une prise de décision financière."},
                    {"role": "user", "content": texte}
                ],
                response_format={"type": "json_object"},
                temperature=0.5,
                max_tokens=1000
            )
            
            resultat = json.loads(completion.choices[0].message.content)
            return RapportFinancier(**resultat)
        except Exception as e:
            print(f"Erreur dans analyser_rapport_financier: {str(e)}")
            return RapportFinancier(
                resume="Une erreur s'est produite lors de l'analyse.",
                metriques_cles=MetriquesFinancieres(chiffre_affaires=0, benefice_net=0, ebitda=0, risques=[])
            )

document_agent = AgentAnalyseDocument()
>>>

./agent_e.py :
<<<
import numpy as np
import yfinance as yf
from scipy.stats import norm
import pandas as pd
from sklearn.covariance import LedoitWolf

class RiskManagementAgent:
    def analyze(self, portfolio, confidence_level=0.95, risk_free_rate=0.02):
        if not portfolio:
            return {"erreur": "Aucun portefeuille trouvé pour cet utilisateur"}

        tickers = [stock['symbol'] for stock in portfolio]
        weights = np.array([stock['weight'] / 100 for stock in portfolio])

        data = yf.download(tickers, period="2y")['Adj Close']
        returns = data.pct_change().dropna()

        # Utilisation de l'estimateur de covariance Ledoit-Wolf pour une meilleure stabilité
        lw = LedoitWolf().fit(returns)
        cov_matrix = lw.covariance_

        portfolio_return = np.sum(returns.mean() * weights) * 252
        portfolio_std = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights))) * np.sqrt(252)

        # Calcul du VaR et CVaR
        VaR = norm.ppf(1-confidence_level) * portfolio_std
        CVaR = -1 * (norm.pdf(norm.ppf(1-confidence_level)) / (1-confidence_level)) * portfolio_std

        # Calcul du ratio de Sharpe
        sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std

        # Calcul des contributions au risque
        marginal_risk = np.dot(cov_matrix, weights) / portfolio_std
        risk_contribution = weights * marginal_risk
        percentage_risk_contribution = risk_contribution / np.sum(risk_contribution)

        # Calcul des drawdowns
        cumulative_returns = (1 + returns).cumprod()
        rolling_max = cumulative_returns.cummax()
        drawdowns = (cumulative_returns - rolling_max) / rolling_max
        max_drawdown = drawdowns.min().min()

        rapport = f"""
Analyse de gestion des risques avancée

1. Mesures de performance:
   Rendement annualisé du portefeuille: {portfolio_return:.2%}
   Volatilité annualisée du portefeuille: {portfolio_std:.2%}
   Ratio de Sharpe: {sharpe_ratio:.2f}

2. Mesures de risque:
   Valeur à Risque (VaR) à {confidence_level*100:.0f}% de confiance: {-VaR:.2%}
   VaR Conditionnelle (CVaR) à {confidence_level*100:.0f}% de confiance: {-CVaR:.2%}
   Drawdown maximal: {max_drawdown:.2%}

3. Contribution au risque par action:
"""
        for ticker, weight, contrib in zip(tickers, weights, percentage_risk_contribution):
            rapport += f"   {ticker}: Poids {weight:.2%}, Contribution au risque {contrib:.2%}\n"

        rapport += f"""
4. Analyse de corrélation:
   Les 3 paires d'actions les plus corrélées:
"""
        corr_matrix = returns.corr()
        corr_pairs = []
        for i in range(len(tickers)):
            for j in range(i+1, len(tickers)):
                corr_pairs.append((tickers[i], tickers[j], corr_matrix.iloc[i, j]))
        corr_pairs.sort(key=lambda x: abs(x[2]), reverse=True)
        for pair in corr_pairs[:3]:
            rapport += f"   {pair[0]} - {pair[1]}: {pair[2]:.2f}\n"

        rapport += f"""
5. Analyse de scénarios:
   Impact estimé d'une baisse de marché de 10%: {-10 * portfolio_std / np.sqrt(252):.2%}
   Impact estimé d'une hausse des taux d'intérêt de 1%: Nécessite une analyse plus approfondie des sensibilités aux taux

Conclusion:
Cette analyse avancée fournit un aperçu détaillé des risques et de la performance du portefeuille. 
Points clés à retenir:
1. Le portefeuille a un ratio de Sharpe de {sharpe_ratio:.2f}, indiquant {'une bonne' if sharpe_ratio > 1 else 'une faible'} performance ajustée au risque.
2. La VaR suggère une perte potentielle maximale de {-VaR:.2%} dans 95% des cas sur une journée.
3. {tickers[np.argmax(percentage_risk_contribution)]} contribue le plus au risque global du portefeuille.
4. Le drawdown maximal de {max_drawdown:.2%} indique la perte maximale historique du portefeuille.

Recommandations:
1. {"Envisager de réduire l'exposition à " + tickers[np.argmax(percentage_risk_contribution)] if max(percentage_risk_contribution) > 0.3 else "La diversification semble adéquate"}
2. {"Le ratio de Sharpe pourrait être amélioré en ajustant l'allocation des actifs" if sharpe_ratio < 1 else "Maintenir la stratégie actuelle qui offre un bon équilibre rendement/risque"}
3. Surveiller de près les corrélations élevées entre certains actifs pour éviter une concentration excessive du risque
4. Envisager des stratégies de couverture pour atténuer l'impact potentiel des scénarios de baisse identifiés

Les investisseurs devraient utiliser ces informations pour ajuster leur stratégie d'investissement en fonction de leur tolérance au risque et de leurs objectifs financiers.
"""
        return rapport

risk_management_agent = RiskManagementAgent()
>>>

./agent_d.py :
<<<
import numpy as np
import pandas as pd
import yfinance as yf
from scipy.optimize import minimize

class PortfolioOptimizationAgent:
    def optimize(self, portfolio):
        if not portfolio:
            return "Désolé, je n'ai pas trouvé de portefeuille à analyser. Pouvez-vous vérifier et me fournir les détails de votre portefeuille ?"

        tickers = [stock['symbol'] for stock in portfolio]
        weights = [float(stock['weight']) / 100 for stock in portfolio]
        
        data = yf.download(tickers, period="5y")['Adj Close']
        returns = data.pct_change().dropna()

        def portfolio_performance(weights, mean_returns, cov_matrix):
            returns = np.sum(mean_returns * weights) * 252
            std = np.sqrt(np.dot(weights, np.dot(cov_matrix, weights))) * np.sqrt(252)
            return std, returns

        def neg_sharpe_ratio(weights, mean_returns, cov_matrix, risk_free_rate):
            p_std, p_ret = portfolio_performance(weights, mean_returns, cov_matrix)
            return -(p_ret - risk_free_rate) / p_std

        def optimize_portfolio(mean_returns, cov_matrix, risk_free_rate):
            num_assets = len(mean_returns)
            args = (mean_returns, cov_matrix, risk_free_rate)
            constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
            bound = (0.0, 1.0)
            bounds = tuple(bound for asset in range(num_assets))
            result = minimize(neg_sharpe_ratio, num_assets*[1./num_assets,], args=args,
                              method='SLSQP', bounds=bounds, constraints=constraints)
            return result

        mean_returns = returns.mean()
        cov_matrix = returns.cov()
        risk_free_rate = 0.01

        opt = optimize_portfolio(mean_returns, cov_matrix, risk_free_rate)
        current_std, current_ret = portfolio_performance(weights, mean_returns, cov_matrix)
        current_sharpe = (current_ret - risk_free_rate) / current_std
        opt_std, opt_ret = portfolio_performance(opt.x, mean_returns, cov_matrix)
        opt_sharpe = (opt_ret - risk_free_rate) / opt_std

        current_weights = {ticker: f"{weight:.2%}" for ticker, weight in zip(tickers, weights)}
        optimized_weights = {ticker: f"{weight:.2%}" for ticker, weight in zip(tickers, opt.x)}

        rapport = f"""Bonjour ! J'ai analysé votre portefeuille et j'ai quelques recommandations intéressantes à vous partager. Voici un résumé de mon analyse :

📊 Votre portefeuille actuel :
{self._format_portfolio(current_weights)}

Avec cette répartition, voici vos indicateurs actuels :
📈 Rendement attendu : {current_ret:.2%}
📉 Volatilité : {current_std:.2%}
💹 Ratio de Sharpe : {current_sharpe:.2f}

Après optimisation, voici ce que je suggère :

🔄 Portefeuille optimisé :
{self._format_portfolio(optimized_weights)}

Cette nouvelle répartition pourrait vous offrir :
📈 Rendement attendu : {opt_ret:.2%} ({opt_ret - current_ret:+.2%})
📉 Volatilité : {opt_std:.2%} ({opt_std - current_std:+.2%})
💹 Ratio de Sharpe : {opt_sharpe:.2f} ({opt_sharpe - current_sharpe:+.2f})

💡 Ce que cela signifie pour vous :
1. Le rendement attendu est {'amélioré' if opt_ret > current_ret else 'réduit'}, passant de {current_ret:.2%} à {opt_ret:.2%}.
2. La volatilité {'augmente' if opt_std > current_std else 'diminue'}, ce qui implique {'plus' if opt_std > current_std else 'moins'} de risque, mais aussi {'plus' if opt_std > current_std else 'moins'} de potentiel de gain.
3. Le ratio de Sharpe {'s\'améliore' if opt_sharpe > current_sharpe else 'se dégrade'}, indiquant un {'meilleur' if opt_sharpe > current_sharpe else 'moins bon'} équilibre rendement/risque.

🔑 Points clés à considérer :
{self._generate_key_points(current_weights, optimized_weights)}

N'oubliez pas que cette analyse est basée sur des données historiques et des modèles mathématiques. Elle ne garantit pas les performances futures. Il est toujours recommandé de diversifier et d'ajuster votre stratégie en fonction de votre situation personnelle et de vos objectifs à long terme.

Que pensez-vous de ces suggestions ? Souhaitez-vous que nous discutions plus en détail de certains aspects spécifiques de cette analyse ?"""

        return rapport

    def _format_portfolio(self, weights):
        return "\n".join([f"- {ticker}: {weight}" for ticker, weight in weights.items()])

    def _generate_key_points(self, current, optimized):
        points = []
        for ticker in current.keys():
            current_weight = float(current[ticker].strip('%')) / 100
            optimized_weight = float(optimized[ticker].strip('%')) / 100
            diff = optimized_weight - current_weight
            if abs(diff) > 0.05:  # Seuil arbitraire pour les changements significatifs
                if diff > 0:
                    points.append(f"- L'optimisation suggère d'augmenter significativement la part de {ticker} (de {current[ticker]} à {optimized[ticker]}).")
                else:
                    points.append(f"- L'optimisation suggère de réduire significativement la part de {ticker} (de {current[ticker]} à {optimized[ticker]}).")
        
        if not points:
            points.append("- Les changements suggérés sont relativement mineurs pour tous les titres.")
        
        return "\n".join(points)

portfolio_optimization_agent = PortfolioOptimizationAgent()

>>>

./wsgi.py :
<<<

from copilote_central import app

if __name__ == "__main__":
    app.run()
>>>

./copilot/src/HistoricalDataAnalysis.js :
<<<
import React, { useState } from 'react';
import axios from 'axios';
import { TextField, Button, Typography, CircularProgress } from '@mui/material';

function HistoricalDataAnalysis() {
    const [ticker, setTicker] = useState('');
    const [analysis, setAnalysis] = useState('');
    const [loading, setLoading] = useState(false);

    const analyzeHistoricalData = async () => {
        setLoading(true);
        try {
            const response = await axios.post('/previous_day_analysis', { ticker });
            setAnalysis(response.data.analysis);
        } catch (error) {
            console.error('Error analyzing historical data:', error);
            setAnalysis('Error analyzing data');
        }
        setLoading(false);
    };

    return (
        <div>
            <Typography variant="h6">Previous Day Data Analysis</Typography>
            <TextField
                label="Stock Ticker"
                value={ticker}
                onChange={(e) => setTicker(e.target.value)}
            />
            <Button onClick={analyzeHistoricalData} disabled={loading}>
                Analyze Data
            </Button>
            {loading ? (
                <CircularProgress />
            ) : (
                <Typography>{analysis}</Typography>
            )}
        </div>
    );
}

export default HistoricalDataAnalysis;
>>>

./copilot/src/ChatBox.js :
<<<
import React, { useRef, useEffect, useCallback } from 'react';
import { Box, TextField, Button, List, ListItem, ListItemText, Paper } from '@mui/material';
import MessageContent from './MessageContent';

function ChatBox({ messages, handleSubmit, loading, customInput, disableInput }) {
    const messagesEndRef = useRef(null);
    const inputRef = useRef(null);

    const scrollToBottom = useCallback(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }, []);

    useEffect(scrollToBottom, [messages]);

    const onSubmit = (e) => {
        e.preventDefault();
        const inputValue = customInput || (inputRef.current ? inputRef.current.value.trim() : '');
        if (inputValue) {
            handleSubmit(e, inputValue);
            if (inputRef.current) {
                inputRef.current.value = ''; // Vider l'input après l'envoi
            }
        }
    };

    return (
        <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Paper sx={{ flexGrow: 1, overflow: 'auto', mb: 2, p: 2 }}>
                <List>
                    {messages.map((message, index) => (
                        <ListItem key={index} alignItems="flex-start">
                            <ListItemText
                                primary={message.role === 'user' ? 'Vous' : 'IA'}
                                secondary={
                                    <>
                                        <MessageContent content={message.content} />
                                        {message.graphs && message.graphs.map((graph, graphIndex) => (
                                            <img
                                                key={graphIndex}
                                                src={`data:image/png;base64,${graph}`}
                                                alt={`Portfolio Graph ${graphIndex + 1}`}
                                                style={{ maxWidth: '100%', marginTop: '10px' }}
                                            />
                                        ))}
                                        {message.graph && (
                                            <img
                                                src={`data:image/png;base64,${message.graph}`}
                                                alt="Graph"
                                                style={{ maxWidth: '100%', marginTop: '10px' }}
                                            />
                                        )}
                                    </>
                                }
                            />
                        </ListItem>
                    ))}
                    <div ref={messagesEndRef} />
                </List>
            </Paper>
            {!disableInput && (
                <Box component="form" onSubmit={onSubmit} sx={{ display: 'flex', position: 'sticky', bottom: 0, bgcolor: 'background.paper' }}>
                    <TextField
                        fullWidth
                        placeholder="Tapez votre message ici..."
                        variant="outlined"
                        disabled={loading}
                        inputRef={inputRef}
                    />
                    <Button
                        type="submit"
                        variant="contained"
                        disabled={loading}
                    >
                        Envoyer
                    </Button>
                </Box>
            )}
        </Box>
    );
}

export default ChatBox;
>>>

./copilot/src/reportWebVitals.js :
<<<
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

>>>

./copilot/src/MessageContent.js :
<<<
import React from 'react';
import ReactMarkdown from 'react-markdown';
import { Typography, Paper, Box } from '@mui/material';

const MessageContent = ({ content, graphs }) => {
    // Fonction pour vérifier si le contenu est valide
    const isValidContent = (content) => {
        return content !== null && content !== undefined && content !== '';
    };

    const isMarkdown = (str) => {
        return typeof str === 'string' && (str.startsWith('# ') || str.includes('\n# ') || str.includes('\n## '));
    };

    // Fonction pour formater le contenu
    const formatContent = (text) => {
        if (!isValidContent(text)) return '';
        return text.replace(/\\n/g, '\n').replace(/\n(?!\n)/g, '\n\n');
    };

    // Fonction pour vérifier si c'est du JSON valide
    const isJSON = (str) => {
        if (!isValidContent(str)) return false;
        try {
            const parsed = JSON.parse(str);
            return typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed) && Object.keys(parsed).length > 0;
        } catch (e) {
            return false;
        }
    };

    // Fonction pour vérifier si c'est un objet string
    const isStringObject = (str) => {
        if (!isValidContent(str)) return false;
        try {
            const parsed = JSON.parse(str);
            return typeof parsed === 'object' && parsed !== null && Object.keys(parsed).every(key => !isNaN(parseInt(key)));
        } catch (e) {
            return false;
        }
    };

    // Gestion du contenu invalide
    // if (!isValidContent(content)) {
    //     console.error("Contenu invalide reçu:", content);
    //     return (
    //         <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
    //             <Typography color="error">Contenu invalide ou non disponible</Typography>
    //         </Paper>
    //     );
    // }

    // Traitement du contenu JSON
    if (isJSON(content)) {
        try {
            const jsonData = JSON.parse(content);
            return (
                <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
                    <pre>{JSON.stringify(jsonData, null, 2)}</pre>
                </Paper>
            );
        } catch (error) {
            console.error("Erreur lors du parsing JSON:", error);
            return (
                <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
                    <Typography color="error">Erreur lors de l'affichage du contenu JSON</Typography>
                </Paper>
            );
        }
    }

    // Traitement du contenu string object
    if (isStringObject(content)) {
        try {
            const stringContent = Object.values(JSON.parse(content)).join('');
            return (
                <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
                    <Typography>{formatContent(stringContent)}</Typography>
                </Paper>
            );
        } catch (error) {
            console.error("Erreur lors du parsing de l'objet string:", error);
            return (
                <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
                    <Typography color="error">Erreur lors de l'affichage du contenu</Typography>
                </Paper>
            );
        }
    }
    // Traitement pour l'agent de reporting
    if (typeof content === 'object' && content.report) {
        return (
            <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
                <Typography variant="h6">Rapport généré</Typography>
                <Box component="a" href={`data:application/pdf;base64,${content.report}`} download="report.pdf">
                    <Typography color="primary">Télécharger le rapport PDF</Typography>
                </Box>
            </Paper>
        );
    }

    // Traitement pour les autres types de contenu
    return (
        <Paper sx={{ p: 2, mt: 1, maxWidth: '100%', overflowX: 'auto' }}>
            <ReactMarkdown
                components={{
                    h1: ({ node, ...props }) => <Typography variant="h4" gutterBottom {...props} />,
                    h2: ({ node, ...props }) => <Typography variant="h5" gutterBottom {...props} />,
                    h3: ({ node, ...props }) => <Typography variant="h6" gutterBottom {...props} />,
                    p: ({ node, ...props }) => <Typography paragraph {...props} />,
                    li: ({ node, ...props }) => <Typography component="li" sx={{ ml: 2 }} {...props} />,
                    ul: ({ node, ...props }) => <Box component="ul" sx={{ pl: 2 }} {...props} />,
                    code: ({ node, inline, ...props }) =>
                        inline ? (
                            <Box component="code" sx={{ bgcolor: 'grey.100', p: 0.5, borderRadius: 1 }} {...props} />
                        ) : (
                            <Box component="pre" sx={{ p: 1, bgcolor: 'grey.100', borderRadius: 1, overflow: 'auto' }}>
                                <code {...props} />
                            </Box>
                        ),
                    img: ({ node, ...props }) => {
                        if (props.src.startsWith('data:image')) {
                            return <img {...props} style={{ maxWidth: '100%', height: 'auto' }} />;
                        }
                        // Gérer les autres types d'images si nécessaire
                        return null;
                    },
                }}
            >
                {formatContent(content)}
            </ReactMarkdown>
            {graphs && graphs.map((graph, index) => (
                <img key={index} src={`data:image/png;base64,${graph}`} alt={`Graph ${index + 1}`} style={{ maxWidth: '100%', marginTop: '10px' }} />
            ))}
        </Paper>
    );
};

export default MessageContent;
>>>

./copilot/src/Auth.js :
<<<
import axios from 'axios';

export const login = async (username, password) => {
    try {
        const response = await axios.post(process.env.REACT_APP_API_URL + '/login', { username, password });
        const { access_token } = response.data;
        localStorage.setItem('token', access_token);
        axios.defaults.headers.common['Authorization'] = `Bearer ${access_token}`;
        return true;
    } catch (error) {
        console.error("Login failed", error);
        return false;
    }
};

export const logout = () => {
    localStorage.removeItem('token');
    delete axios.defaults.headers.common['Authorization'];
};
>>>

./copilot/src/index.js :
<<<
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

>>>

./copilot/src/Register.js :
<<<
import React, { useState } from 'react';
import { TextField, Button, Box } from '@mui/material';
import axios from 'axios';

function Register({ onRegisterSuccess }) {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            const response = await axios.post(`${process.env.REACT_APP_API_URL}/register`, {
                username,
                password
            }, {
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            console.log(response.data); // Pour le débogage

            alert('Registration successful! Please log in.');
            onRegisterSuccess();
        } catch (error) {
            console.error("Registration error:", error.response ? error.response.data : error.message);
            alert('Registration failed. Please try again.');
        }
    };

    return (
        <Box component="form" onSubmit={handleSubmit}>
            <TextField
                label="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                fullWidth
                margin="normal"
            />
            <TextField
                label="Password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                fullWidth
                margin="normal"
            />
            <Button type="submit" variant="contained" color="primary">
                Register
            </Button>
        </Box>
    );
}

export default Register;

>>>

./copilot/src/InvestmentRecommendation.js :
<<<
import React, { useState } from 'react';
import axios from 'axios';
import { TextField, Button, Typography, CircularProgress, Select, MenuItem } from '@mui/material';

function InvestmentRecommendation() {
    const [portfolio, setPortfolio] = useState('');
    const [riskProfile, setRiskProfile] = useState('moderate');
    const [recommendation, setRecommendation] = useState('');
    const [loading, setLoading] = useState(false);

    const getRecommendation = async () => {
        setLoading(true);
        try {
            const response = await axios.post('/investment_recommendation', {
                portfolio: portfolio.split(',').map(stock => stock.trim()),
                risk_profile: riskProfile
            });
            setRecommendation(response.data.recommendation);
        } catch (error) {
            console.error('Error getting investment recommendation:', error);
            setRecommendation('Error getting recommendation');
        }
        setLoading(false);
    };

    return (
        <div>
            <Typography variant="h6">Investment Recommendation</Typography>
            <TextField
                label="Portfolio (comma-separated tickers)"
                value={portfolio}
                onChange={(e) => setPortfolio(e.target.value)}
            />
            <Select
                value={riskProfile}
                onChange={(e) => setRiskProfile(e.target.value)}
            >
                <MenuItem value="conservative">Conservative</MenuItem>
                <MenuItem value="moderate">Moderate</MenuItem>
                <MenuItem value="aggressive">Aggressive</MenuItem>
            </Select>
            <Button onClick={getRecommendation} disabled={loading}>
                Get Recommendation
            </Button>
            {loading ? (
                <CircularProgress />
            ) : (
                <Typography>{recommendation}</Typography>
            )}
        </div>
    );
}

export default InvestmentRecommendation;
>>>

./copilot/src/Login.js :
<<<
import React, { useState } from 'react';
import { TextField, Button, Box } from '@mui/material';
import { login } from './Auth'

function Login({ onLogin }) {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        const success = await login(username, password);
        if (success) {
            onLogin();
        } else {
            alert('Login failed');
        }
    };

    return (
        <Box component="form" onSubmit={handleSubmit}>
            <TextField
                label="Username"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                fullWidth
                margin="normal"
            />
            <TextField
                label="Password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                fullWidth
                margin="normal"
            />
            <Button type="submit" variant="contained" color="primary">
                Login
            </Button>
        </Box>
    );
}

export default Login;
>>>

./copilot/src/ErrorBoundary.js :
<<<
import React from 'react';

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, errorInfo) {
        console.log('Error caught by ErrorBoundary:', error, errorInfo);
    }

    render() {
        if (this.state.hasError) {
            return <h1>Something went wrong.</h1>;
        }

        return this.props.children;
    }
}

export default ErrorBoundary;
>>>

./copilot/src/MarketSentiment.js :
<<<
import React, { useState } from 'react';
import axios from 'axios';
import { TextField, Button, Typography, CircularProgress } from '@mui/material';

function MarketSentiment() {
    const [ticker, setTicker] = useState('');
    const [sentiment, setSentiment] = useState('');
    const [loading, setLoading] = useState(false);

    const analyzeSentiment = async () => {
        setLoading(true);
        try {
            const response = await axios.post('/market_sentiment', { ticker });
            setSentiment(response.data.sentiment);
        } catch (error) {
            console.error('Error analyzing market sentiment:', error);
            setSentiment('Error analyzing sentiment');
        }
        setLoading(false);
    };

    return (
        <div>
            <Typography variant="h6">Market Sentiment Analysis</Typography>
            <TextField
                label="Stock Ticker"
                value={ticker}
                onChange={(e) => setTicker(e.target.value)}
            />
            <Button onClick={analyzeSentiment} disabled={loading}>
                Analyze Sentiment
            </Button>
            {loading ? (
                <CircularProgress />
            ) : (
                <Typography>{sentiment}</Typography>
            )}
        </div>
    );
}

export default MarketSentiment;
>>>

./copilot/src/UserProfileAnalysis.js :
<<<
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Typography, CircularProgress, Button } from '@mui/material';

function UserProfileAnalysis() {
    const [analysis, setAnalysis] = useState('');
    const [loading, setLoading] = useState(false);

    const getProfileAnalysis = async () => {
        setLoading(true);
        try {
            const response = await axios.post('/user_profile_analysis');
            setAnalysis(response.data.analysis);
        } catch (error) {
            console.error('Error getting user profile analysis:', error);
            setAnalysis('Error analyzing user profile');
        }
        setLoading(false);
    };

    return (
        <div>
            <Typography variant="h6">User Profile Analysis</Typography>
            <Button onClick={getProfileAnalysis} disabled={loading}>
                Analyze My Profile
            </Button>
            {loading ? (
                <CircularProgress />
            ) : (
                <Typography>{analysis}</Typography>
            )}
        </div>
    );
}

export default UserProfileAnalysis;
>>>

./copilot/src/Portfolio.js :
<<<
import React, { useState, useEffect, useCallback } from 'react';
import {
    TextField, Button, Table, TableBody, TableCell, TableHead, TableRow, Paper, List, ListItem, ListItemText, Typography, Dialog, DialogTitle, DialogContent, DialogActions, Select, MenuItem, CircularProgress, InputAdornment, Autocomplete, IconButton, Box, Switch, FormControlLabel, Tooltip
} from '@mui/material';
import {
    PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip as RechartsTooltip, LineChart, Line, XAxis, YAxis, CartesianGrid
} from 'recharts';
import SaveIcon from '@mui/icons-material/Save';
import SimulationIcon from '@mui/icons-material/Timeline';
import ReportIcon from '@mui/icons-material/Assessment';
import { Info } from '@mui/icons-material';
import axios from 'axios';

export const PortfolioPieChart = ({ portfolio }) => {
    if (!portfolio || !portfolio.stocks || portfolio.stocks.length === 0) {
        return <Typography>Aucune donnée de portefeuille disponible pour le graphique</Typography>;
    }

    const data = portfolio.stocks.map(stock => ({
        name: stock.symbol,
        value: parseFloat(stock.weight),
        entryPrice: parseFloat(stock.entry_price)
    }));

    const COLORS = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];

    const renderCustomizedLabel = ({
        cx, cy, midAngle, innerRadius, outerRadius, percent, index
    }) => {
        const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
        const x = cx + radius * Math.cos(-midAngle * Math.PI / 180);
        const y = cy + radius * Math.sin(-midAngle * Math.PI / 180);

        return (
            <text x={x} y={y} fill="white" textAnchor={x > cx ? 'start' : 'end'} dominantBaseline="central">
                {`${data[index].name} ${(percent * 100).toFixed(0)}%`}
            </text>
        );
    };

    return (
        <ResponsiveContainer width="100%" height={400}>
            <PieChart>
                <Pie
                    data={data}
                    cx="50%"
                    cy="50%"
                    labelLine={false}
                    label={renderCustomizedLabel}
                    outerRadius={150}
                    fill="#8884d8"
                    dataKey="value"
                >
                    {data.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                </Pie>
                <RechartsTooltip content={({ active, payload }) => {
                    if (active && payload && payload.length) {
                        const data = payload[0].payload;
                        return (
                            <div style={{ backgroundColor: '#fff', padding: '5px', border: '1px solid #ccc' }}>
                                <p>{`${data.name} : ${(data.value * 100).toFixed(2)}%`}</p>
                                <p>{`Prix d'entrée : $${data.entryPrice}`}</p>
                            </div>
                        );
                    }
                    return null;
                }} />
                <Legend />
            </PieChart>
        </ResponsiveContainer>
    );
};

function Portfolio() {
    const [portfolio, setPortfolio] = useState({ name: 'default', stocks: [] });
    const [newStock, setNewStock] = useState({ symbol: '', weight: '', entryPrice: '' });
    const [livePrices, setLivePrices] = useState({});
    const [news, setNews] = useState([]);
    const [scenarioResults, setScenarioResults] = useState(null);
    const [openScenario, setOpenScenario] = useState(false);
    const [selectedScenario, setSelectedScenario] = useState('market_crash');
    const [openReport, setOpenReport] = useState(false);
    const [reportData, setReportData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [portfolioValue, setPortfolioValue] = useState(100000); // Valeur par défaut
    const [displayMode, setDisplayMode] = useState('weight'); // 'weight' ou 'shares'
    const [editingStock, setEditingStock] = useState(null);
    const [reportProgress, setReportProgress] = useState(0);
    const [currentStep, setCurrentStep] = useState('');

    const handleSubmit = (event) => {
        event.preventDefault();
        if (newStock.symbol && newStock.weight && newStock.entryPrice) {
            addStock();
        } else {
            alert('Veuillez remplir tous les champs');
        }
    };

    const handleChange = (e) => {
        setNewStock({ ...newStock, [e.target.name]: e.target.value });
    };

    useEffect(() => {
        fetchPortfolio();
    }, []);

    useEffect(() => {
        if (portfolio.stocks && portfolio.stocks.length > 0) {
            fetchLatestPrices();
        }
    }, [portfolio]);

    useEffect(() => {
        const fetchNewsAndTranslate = async () => {
            if (!portfolio || !portfolio.stocks) {
                console.error("Portfolio ou portfolio.stocks est indéfini");
                return;
            }
            const tickers = portfolio.stocks.map(stock => stock.symbol).join(',');
            try {
                const response = await axios.get(`${process.env.REACT_APP_API_URL}/news?tickers=${tickers}`);
                console.log("Nouvelles reçues:", response.data);
                const translatedResponse = await axios.post(`${process.env.REACT_APP_API_URL}/translate_news`, {
                    news: response.data
                }, {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                console.log("Nouvelles traduites:", translatedResponse.data);
                setNews(translatedResponse.data);
            } catch (error) {
                console.error("Erreur lors de la récupération ou de la traduction des nouvelles:", error);
            } finally {
                setLoading(false);
            }
        };
        fetchNewsAndTranslate();
    }, [portfolio]);


        useEffect(() => {
            if (newStock.symbol) {
                const fetchNewStockPrice = async () => {
                    try {
                        const response = await axios.get(`${process.env.REACT_APP_API_URL}/latest_price?symbol=${newStock.symbol}`);
                        if (response.data && response.data.price) {
                            setLivePrices(prev => ({ ...prev, [newStock.symbol]: response.data.price }));
                        }
                    } catch (error) {
                        console.error(`Erreur lors de la récupération du prix pour ${newStock.symbol}:`, error);
                    }
                };
                fetchNewStockPrice();
            }
        }, [newStock.symbol]);

        useEffect(() => {
            const fetchPortfolioValue = async () => {
                try {
                    const response = await axios.get(process.env.REACT_APP_API_URL + '/get_portfolio_value', {
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                    });
                    setPortfolioValue(response.data.portfolio_value);
                } catch (error) {
                    console.error("Error fetching portfolio value:", error);
                }
            };
            fetchPortfolioValue();
        }, []);

        const updatePortfolioValue = async (newValue) => {
            try {
                await axios.post(process.env.REACT_APP_API_URL + '/update_portfolio_value',
                    { portfolio_value: newValue },
                    { headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` } }
                );
                setPortfolioValue(newValue);
            } catch (error) {
                console.error("Error updating portfolio value:", error);
            }
        };

        const fetchPortfolio = async () => {
            try {
                const response = await axios.get(process.env.REACT_APP_API_URL + '/portfolio');
                setPortfolio(response.data);
            } catch (error) {
                console.error("Erreur lors de la récupération du portfolio:", error);
            } finally {
                setLoading(false);
            }
        };

        const calculateValue = (stock) => {
            const currentPrice = livePrices[stock.symbol] || parseFloat(stock.entry_price);
            return displayMode === 'weight'
                ? (parseFloat(stock.weight) / 100) * portfolioValue
                : parseFloat(stock.shares || stock.weight) * currentPrice;
        };

        const fetchLatestPrices = async () => {
            if (!portfolio || !portfolio.stocks) {
                console.error("Portfolio or portfolio.stocks is undefined");
                return;
            }
            const updatedPrices = { ...livePrices };
            for (const stock of portfolio.stocks) {
                try {
                    const response = await axios.get(`${process.env.REACT_APP_API_URL}/latest_price?symbol=${stock.symbol}`);
                    if (response.data && response.data.price) {
                        updatedPrices[stock.symbol] = response.data.price;
                    }
                } catch (error) {
                    console.error(`Erreur lors de la récupération du prix pour ${stock.symbol}:`, error);
                }
            }
            setLivePrices(updatedPrices);
        };

        const addStock = () => {
            setPortfolio(prevPortfolio => ({
                ...prevPortfolio,
                stocks: [...(prevPortfolio.stocks || []), {
                    symbol: newStock.symbol,
                    weight: newStock.weight,
                    entry_price: newStock.entryPrice
                }]
            }));
            setNewStock({ symbol: '', weight: '', entryPrice: '' });
        };

        const savePortfolio = async () => {
            try {
                const response = await axios.post(process.env.REACT_APP_API_URL + '/portfolio', portfolio);
                if (response.status === 200) {
                    alert('Portfolio sauvegardé avec succès!');
                    fetchPortfolio();
                } else {
                    alert('Erreur lors de la sauvegarde du portfolio.');
                }
            } catch (error) {
                console.error("Erreur lors de la sauvegarde du portfolio:", error);
                alert('Erreur lors de la sauvegarde du portfolio. Veuillez réessayer.');
            }
        };

        const simulateScenario = async () => {
            try {
                const response = await axios.post(process.env.REACT_APP_API_URL + '/simulate_scenario', {
                    portfolio: {
                        stocks: portfolio.stocks.map(stock => ({
                            symbol: stock.symbol,
                            weight: parseFloat(stock.weight)
                        }))
                    },
                    scenario: selectedScenario
                });
                setScenarioResults(response.data);
                setOpenScenario(true);
            } catch (error) {
                console.error("Erreur lors de la simulation du scénario:", error);
                alert('Erreur lors de la simulation du scénario. Veuillez réessayer.');
            }
        };

        const generateReport = async () => {
            setLoading(true);
            try {
                const response = await axios.post(
                    `${process.env.REACT_APP_API_URL}/generate_report`,
                    { portfolio: portfolio },
                    {
                        responseType: 'json',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    }
                );

                console.log("Response data:", response.data); // Ajoutez cette ligne pour déboguer

                if (response.data && response.data.report) {
                    setReportData(response.data.report);
                    setOpenReport(true);
                } else {
                    console.error("Invalid report data:", response.data); // Ajoutez cette ligne
                    throw new Error('Invalid report data received');
                }
            } catch (error) {
                console.error("Erreur lors de la génération du rapport:", error);
                alert(`Erreur lors de la génération du rapport: ${error.message}`);
            } finally {
                setLoading(false);
            }
        };

        const handleEditStock = (index) => {
            setEditingStock(index);
        };

        const handleSaveStock = (index) => {
            setEditingStock(null);
            // Ici, vous pouvez ajouter une logique pour sauvegarder les modifications dans la base de données
        };

        const handleStockChange = (index, field, value) => {
            const updatedStocks = [...portfolio.stocks];
            updatedStocks[index] = { ...updatedStocks[index], [field]: value };
            setPortfolio({ ...portfolio, stocks: updatedStocks });
        };

        const formatNumber = (number) => {
            return new Intl.NumberFormat('fr-FR', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(number);
        };

        const calculateDiff = (entryPrice, currentPrice, shares) => {
            const diff = (currentPrice - entryPrice) * shares;
            const color = diff >= 0 ? 'green' : 'red';
            return { diff, color };
        };

        if (loading) {
            return <CircularProgress />;
        }

        return (
            <Paper sx={{ padding: 2 }}>
                <Typography variant="h6">Dernières Nouvelles</Typography>
                {loading ? (
                    <CircularProgress />
                ) : news && news.length > 0 ? (
                    <List>
                        {news.map((item, index) => (
                            <ListItem key={index}>
                                <ListItemText primary={item.title} secondary={item.description} />
                            </ListItem>
                        ))}
                    </List>
                ) : (
                    <Typography>Aucune nouvelle disponible pour les actions actuelles</Typography>
                )}

                <form onSubmit={handleSubmit}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
                        <Autocomplete
                            options={['AAPL', 'GOOGL', 'MSFT', 'AMZN']}
                            renderInput={(params) => <TextField {...params} label="Symbole de l'action" />}
                            onInputChange={(event, newValue) => setNewStock({ ...newStock, symbol: newValue })}
                            value={newStock.symbol}
                            sx={{ flexGrow: 1 }}
                        />
                        <TextField
                            label={displayMode === 'weight' ? "Poids (%)" : "Nombre d'actions"}
                            type="number"
                            name={displayMode === 'weight' ? 'weight' : 'shares'}
                            value={displayMode === 'weight' ? newStock.weight : newStock.shares}
                            onChange={handleChange}
                            InputProps={{
                                endAdornment: displayMode === 'weight' ? <InputAdornment position="end">%</InputAdornment> : null,
                            }}
                            sx={{ flexGrow: 1 }}
                        />
                        <TextField
                            label="Prix d'entrée"
                            type="number"
                            name="entryPrice"
                            value={newStock.entryPrice}
                            onChange={handleChange}
                            sx={{ flexGrow: 1 }}
                        />
                        <Tooltip title={`Le ${displayMode === 'weight' ? 'poids' : 'nombre d\'actions'} représente ${displayMode === 'weight' ? 'le pourcentage' : 'la quantité'} de l'action dans votre portefeuille.`}>
                            <IconButton>
                                <Info />
                            </IconButton>
                        </Tooltip>
                        <Button type="submit" variant="contained" color="primary">Ajouter</Button>
                    </Box>
                </form>

                {portfolio && portfolio.stocks && portfolio.stocks.length > 0 ? (
                    <>
                        <Table>
                            <TableHead>
                                <TableRow>
                                    <TableCell>Symbole</TableCell>
                                    <TableCell>{displayMode === 'weight' ? 'Poids (%)' : 'Actions'}</TableCell>
                                    <TableCell>Prix d'entrée</TableCell>
                                    <TableCell>Prix actuel</TableCell>
                                    <TableCell>Valeur</TableCell>
                                    <TableCell>Différence</TableCell>
                                    <TableCell>Actions</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {portfolio.stocks.map((stock, index) => {
                                    const shares = displayMode === 'weight'
                                        ? (parseFloat(stock.weight) / 100) * portfolioValue / parseFloat(stock.entry_price)
                                        : parseFloat(stock.weight);
                                    const currentPrice = livePrices[stock.symbol] || parseFloat(stock.entry_price);
                                    const value = shares * currentPrice;
                                    const { diff, color } = calculateDiff(parseFloat(stock.entry_price), currentPrice, shares);
                                    return (
                                        <TableRow key={index}>
                                            <TableCell>{stock.symbol}</TableCell>
                                            <TableCell>
                                                {editingStock === index ? (
                                                    <TextField
                                                        type="number"
                                                        value={displayMode === 'weight' ? stock.weight : shares}
                                                        onChange={(e) => handleStockChange(index, displayMode === 'weight' ? 'weight' : 'shares', e.target.value)}
                                                        InputProps={displayMode === 'weight' ? {
                                                            endAdornment: <InputAdornment position="end">%</InputAdornment>,
                                                        } : {}}
                                                    />
                                                ) : (
                                                    displayMode === 'weight'
                                                        ? `${formatNumber(parseFloat(stock.weight))}%`
                                                        : formatNumber(shares)
                                                )}
                                            </TableCell>
                                            <TableCell>
                                                {editingStock === index ? (
                                                    <TextField
                                                        type="number"
                                                        value={stock.entry_price}
                                                        onChange={(e) => handleStockChange(index, 'entry_price', e.target.value)}
                                                    />
                                                ) : (
                                                    formatNumber(parseFloat(stock.entry_price))
                                                )}
                                            </TableCell>
                                            <TableCell>{currentPrice ? formatNumber(currentPrice) : 'Loading...'}</TableCell>
                                            <TableCell>{formatNumber(value)}</TableCell>
                                            <TableCell style={{ color }}>{formatNumber(diff)}</TableCell>
                                            <TableCell>
                                                {editingStock === index ? (
                                                    <Button onClick={() => handleSaveStock(index)}>Save</Button>
                                                ) : (
                                                    <Button onClick={() => handleEditStock(index)}>Edit</Button>
                                                )}
                                            </TableCell>
                                        </TableRow>
                                    );
                                })}
                            </TableBody>
                        </Table>
                        <Typography variant="h6" sx={{ mt: 3, mb: 1 }}>Allocation du Portefeuille</Typography>
                        <PortfolioPieChart portfolio={portfolio} />
                    </>
                ) : (
                    <Typography sx={{ my: 2 }}>Le portefeuille est actuellement vide. Ajoutez des actions pour commencer.</Typography>
                )}

                <Box sx={{ mt: 3 }}>
                    <TextField
                        label="Valeur du Portefeuille"
                        value={formatNumber(portfolioValue)}
                        onChange={(e) => {
                            const newValue = parseFloat(e.target.value.replace(/[^0-9,-]/g, '').replace(',', '.'));
                            if (!isNaN(newValue)) {
                                setPortfolioValue(newValue);
                                updatePortfolioValue(newValue);
                            }
                        }}
                        fullWidth
                        margin="normal"
                    />
                    <Typography variant="h6" sx={{ mt: 2 }}>Valeur Actuelle du Portefeuille: {portfolioValue.toFixed(2)}</Typography>
                    <FormControlLabel
                        control={<Switch checked={displayMode === 'shares'} onChange={() => setDisplayMode(displayMode === 'weight' ? 'shares' : 'weight')} />}
                        label={`Passer en mode ${displayMode === 'weight' ? 'Actions' : 'Poids'}`}
                        sx={{ mt: 2 }}
                    />
                </Box>

                <Box sx={{ mt: 3, display: 'flex', gap: 2 }}>
                    <Button onClick={() => savePortfolio(portfolio.stocks)} variant="contained" color="secondary" startIcon={<SaveIcon />}>
                        Sauvegarder le Portefeuille
                    </Button>
                    <Button onClick={() => setOpenScenario(true)} variant="contained" startIcon={<SimulationIcon />}>Simuler un Scénario</Button>
                    <Button onClick={generateReport} variant="contained" startIcon={<ReportIcon />}>Générer un Rapport</Button>
                </Box>

                <Dialog
                    open={openScenario}
                    onClose={() => setOpenScenario(false)}
                    fullWidth
                    maxWidth="md"
                >
                    <DialogTitle>Simulation de Scénario</DialogTitle>
                    <DialogContent>
                        <Select
                            value={selectedScenario}
                            onChange={(e) => setSelectedScenario(e.target.value)}
                            fullWidth
                            sx={{ mb: 2 }}
                        >
                            <MenuItem value="market_crash">Krach Boursier</MenuItem>
                            <MenuItem value="bull_market">Marché Haussier</MenuItem>
                            <MenuItem value="high_inflation">Forte Inflation</MenuItem>
                        </Select>
                        <Button onClick={simulateScenario} variant="contained" sx={{ mb: 2 }}>Lancer la Simulation</Button>
                        {scenarioResults && scenarioResults.daily_returns && scenarioResults.daily_returns.length > 0 ? (
                            <Box>
                                <Typography>Scénario: {scenarioResults.scenario}</Typography>
                                <Typography>Valeur Initiale: {scenarioResults.initial_value.toFixed(2)} €</Typography>
                                <Typography>Valeur Finale: {scenarioResults.final_value.toFixed(2)} €</Typography>
                                <Typography>Rendement Total: {(scenarioResults.total_return * 100).toFixed(2)}%</Typography>
                                <Box sx={{ width: '100%', height: 400 }}>
                                    <ResponsiveContainer width="100%" height={400}>
                                        <LineChart data={scenarioResults.portfolio_values.map((value, index) => ({ day: index, value: value }))}>
                                            <XAxis
                                                dataKey="day"
                                                tickFormatter={(tick) => `Jour ${tick + 1}`}
                                            />
                                            <YAxis
                                                tickFormatter={(value) => `$${value.toFixed(0)}`}
                                            />
                                            <CartesianGrid strokeDasharray="3 3" />
                                            <RechartsTooltip
                                                formatter={(value) => [`$${value.toFixed(2)}`, "Valeur du Portefeuille"]}
                                                labelFormatter={(label) => `Jour ${label + 1}`}
                                            />
                                            <Legend />
                                            <Line type="monotone" dataKey="value" stroke="#8884d8" dot={false} name="Valeur du Portefeuille" />
                                        </LineChart>
                                    </ResponsiveContainer>
                                </Box>
                            </Box>
                        ) : (
                            <Typography>Aucune donnée de scénario disponible</Typography>
                        )}
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setOpenScenario(false)}>Fermer</Button>
                    </DialogActions>
                </Dialog>

                <Dialog open={openReport} onClose={() => setOpenReport(false)} maxWidth="md" fullWidth>
                    <DialogTitle>Rapport du Portefeuille</DialogTitle>
                    <DialogContent>
                        {reportData ? (
                            <iframe
                                src={`data:application/pdf;base64,${reportData}`}
                                width="100%"
                                height="500px"
                                style={{ border: 'none' }}
                            />
                        ) : (
                            <Typography>Aucune donnée de rapport disponible</Typography>
                        )}
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setOpenReport(false)}>Fermer</Button>
                        {reportData && (
                            <Button onClick={() => {
                                const linkSource = `data:application/pdf;base64,${reportData}`;
                                const downloadLink = document.createElement("a");
                                downloadLink.href = linkSource;
                                downloadLink.download = "rapport_portefeuille.pdf";
                                downloadLink.click();
                            }}>
                                Télécharger le PDF
                            </Button>
                        )}
                    </DialogActions>
                </Dialog>
            </Paper>
        );
    }

export default Portfolio;
>>>

./copilot/src/Dashboard.js :
<<<
import React from 'react';
import { Grid, Paper, Typography } from '@mui/material';
import { PortfolioPieChart } from './Portfolio';  // Assurez-vous d'exporter PortfolioPieChart depuis Portfolio.js

function Dashboard({ portfolio }) {
    console.log('Dashboard portfolio:', portfolio); // Pour déboguer

    if (!portfolio) {
        return <Typography>Chargement du portfolio...</Typography>;
    }

    if (!portfolio.stocks || portfolio.stocks.length === 0) {
        return <Typography>Aucune donnée de portfolio disponible</Typography>;
    }

    // const totalValue = portfolio.stocks.reduce((sum, stock) => sum + parseFloat(stock.weight) * parseFloat(stock.entryPrice), 0);

    // return (
    //     <Grid container spacing={3}>
    //         <Grid item xs={12} md={6}>
    //             <Paper elevation={3} style={{ padding: '20px' }}>
    //                 <Typography variant="h6">Valeur du Portfolio</Typography>
    //                 <Typography variant="h4">${totalValue.toFixed(2)}</Typography>
    //             </Paper>
    //         </Grid>
    //         <Grid item xs={12} md={6}>
    //             <Paper elevation={3} style={{ padding: '20px' }}>
    //                 <Typography variant="h6">Allocation du Portfolio</Typography>
    //                 <PortfolioPieChart portfolio={portfolio} />
    //             </Paper>
    //         </Grid>
    //     </Grid>
    // );
    if (!portfolio || !portfolio.stocks) {
        return <Typography>Aucun portefeuille disponible</Typography>;
    }

    const totalValue = portfolio.stocks.reduce((sum, stock) => sum + stock.weight * stock.entryPrice, 0);

    return (
        <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
                <Paper elevation={3} style={{ padding: '20px' }}>
                    <Typography variant="h6">Portfolio Value</Typography>
                    <Typography variant="h4">${totalValue.toFixed(2)}</Typography>
                </Paper>
            </Grid>
            <Grid item xs={12} md={6}>
                <Paper elevation={3} style={{ padding: '20px' }}>
                    <Typography variant="h6">Portfolio Allocation</Typography>
                    {portfolio && portfolio.stocks && portfolio.stocks.length > 0 ? (
                        <PortfolioPieChart portfolio={portfolio} />
                    ) : (
                        <Typography>Aucune donnée disponible</Typography>
                    )}
                </Paper>
            </Grid>
            {/* Ajoutez d'autres widgets ici */}
        </Grid>
    );
}

export default Dashboard;
>>>

./copilot/src/setupTests.js :
<<<
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

>>>

./copilot/src/App.js :
<<<
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { ThemeProvider, createTheme, styled, alpha } from '@mui/material/styles';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import {
    Container, TextField, Button, Paper, Typography, List, ListItem, ListItemText,
    Tab, Tabs, CircularProgress, Box, Fade, Slide, Dialog, DialogTitle,
    DialogContent, DialogActions, Select, MenuItem, AppBar, Switch,
    FormControlLabel, Toolbar, IconButton, Drawer, ListItemIcon, InputBase,
    Badge, Menu, useMediaQuery, CssBaseline, Stack
} from '@mui/material';
import {
    Menu as MenuIcon,
    Dashboard as DashboardIcon,
    AccountBalance as AccountBalanceIcon,
    TrendingUp as TrendingUpIcon,
    Settings as SettingsIcon,
    Logout as LogoutIcon,
    Chat as ChatIcon,
    GroupWork as GroupWorkIcon,
    PictureAsPdf as PictureAsPdfIcon,
    AccountCircle,
    Notifications as NotificationsIcon,
    MonetizationOn as MonetizationOnIcon,
    History as HistoryIcon,
    Person as PersonIcon
} from '@mui/icons-material';
import Settings from './Settings';
import Portfolio from './Portfolio';
import Login from './Login';
import Register from './Register';
import Dashboard from './Dashboard';
import MarketSentiment from './MarketSentiment';
import InvestmentRecommendation from './InvestmentRecommendation';
import HistoricalDataAnalysis from './HistoricalDataAnalysis';
import UserProfileAnalysis from './UserProfileAnalysis';
import MessageContent from './MessageContent'
import axios from 'axios';
import { logout } from './Auth';
import ErrorBoundary from './ErrorBoundary';
import ChatBox from './ChatBox';

const api = axios.create({
    baseURL: process.env.REACT_APP_API_URL,
    headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    },
    withCredentials: true
});

api.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers['Authorization'] = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

const drawerWidth = 240;

function App() {
    const [darkMode, setDarkMode] = useState(false);
    const [open, setOpen] = useState(true);
    const [input, setInput] = useState('');
    const [messages, setMessages] = useState([]);
    const [activeTab, setActiveTab] = useState(0);
    const [loading, setLoading] = useState(false);
    const [isLoggedIn, setIsLoggedIn] = useState(false);
    const [showLogin, setShowLogin] = useState(true);
    const [openBacktest, setOpenBacktest] = useState(false);
    const [backtestResults, setBacktestResults] = useState(null);
    const [startDate, setStartDate] = useState('');
    const [endDate, setEndDate] = useState('');
    const [openComparison, setOpenComparison] = useState(false);
    const [comparisonResults, setComparisonResults] = useState(null);
    const [benchmark, setBenchmark] = useState('SPY');
    const [comparisonStartDate, setComparisonStartDate] = useState('');
    const [comparisonEndDate, setComparisonEndDate] = useState('');
    const [conversationId, setConversationId] = useState(null);
    const [file, setFile] = useState(null);
    const [portfolio, setPortfolio] = useState([]);
    const [portfolioLoading, setPortfolioLoading] = useState(true);
    const [news, setNews] = useState([]);
    const [settings, setSettings] = useState({
        risk_tolerance: 'moderate',
    });
    const agentInputRef = useRef(null);

    const toggleDarkMode = () => {
        setDarkMode(!darkMode);
    };

    const theme = createTheme({
        palette: {
            mode: darkMode ? 'dark' : 'light',
            primary: {
                main: '#1976d2',
            },
            secondary: {
                main: '#dc004e',
            },
        },
        typography: {
            fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
            h4: {
                fontWeight: 600,
            },
        },
        components: {
            MuiButton: {
                styleOverrides: {
                    root: {
                        textTransform: 'none',
                    },
                },
            },
            MuiPaper: {
                styleOverrides: {
                    root: {
                        borderRadius: 8,
                    },
                },
            },
        },
    });

    const fetchSettings = async () => {
        try {
            const response = await axios.get(
                `${process.env.REACT_APP_API_URL}/settings`,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                }
            );
            setSettings(response.data);
        } catch (error) {
            console.error('Erreur lors de la récupération des paramètres:', error);
            if (error.response) {
                console.error('Données de réponse:', error.response.data);
            }
        }
    };

    useEffect(() => {
        fetchSettings();
    }, []);


    useEffect(() => {
        const token = localStorage.getItem('token');
        if (token) {
            setIsLoggedIn(true);
        }
    }, []);

    const clearChatHistory = useCallback(() => {
        setMessages([]);
        setConversationId(null);
    }, []);

    useEffect(() => {
        const fetchChatHistory = async () => {
            try {
                const response = await axios.get(`${process.env.REACT_APP_API_URL}/chat_history`, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                setMessages(response.data.reverse());
            } catch (error) {
                console.error('Error fetching chat history:', error);
            }
        };

        if (isLoggedIn) {
            fetchChatHistory();
        }
    }, [isLoggedIn]);

    const fetchPortfolio = async () => {
        try {
            const response = await axios.get(process.env.REACT_APP_API_URL + '/portfolio');
            setPortfolio(response.data);
        } catch (error) {
            console.error("Erreur lors de la récupération du portfolio:", error);
        } finally {
            setLoading(false);
        }
    };

    const fetchNews = async () => {
        setLoading(true);
        const tickers = portfolio.map(stock => stock.symbol).join(',');
        try {
            const response = await axios.get(`${process.env.REACT_APP_API_URL}/news?tickers=${tickers}`);
            setNews(response.data);
        } catch (error) {
            console.error("Erreur lors de la récupération des nouvelles:", error);
            setNews([]);
        } finally {
            setLoading(false);
        }
    };

    const fetchLivePrice = useCallback(async (symbol) => {
        if (!symbol) return null;
        try {
            const response = await axios.get(`${process.env.REACT_APP_API_URL}/live_price?symbol=${symbol}`);
            return response.data.price;
        } catch (error) {
            console.error(`Error fetching live price for ${symbol}:`, error);
            return null;
        }
    }, []);

    useEffect(() => {
        fetchLivePrice();
    }, [fetchLivePrice]);

    useEffect(() => {
        if (portfolio.length > 0) {
            fetchNews();
        }
    }, [portfolio]);

    const handleAgentCall = async (agentName) => {
        setLoading(true);
        // Récupérez la valeur actuelle de l'input
        const inputValue = agentInputRef.current ? agentInputRef.current.value : '';
        let data = {};
        switch (agentName) {
            case 'document':
                data = { text: inputValue };
                break;
            case 'sentiment':
                data = { company: inputValue };
                break;
            case 'financial_modeling':
                data = { ticker: inputValue };
                break;
            case 'portfolio_optimization':
            case 'risk_management':
                data = { tickers: inputValue.split(','), portfolio_value: 100000 };
                break;
            case 'reporting':
                data = { portfolio_data: portfolio.stocks };
                break;
            case 'compliance':
                try {
                    const parsedInput = JSON.parse(inputValue);
                    data = { portfolio_data: parsedInput };
                } catch (error) {
                    console.warn("Input is not valid JSON, treating it as a string representation of portfolio");
                    const portfolioArray = inputValue.split(',').map(item => {
                        const [symbol, weight] = item.split(':');
                        return { symbol, weight: parseFloat(weight) };
                    });
                    data = { portfolio_data: portfolioArray };
                }
                break;
            case 'market_sentiment':
                data = { ticker: inputValue };
                break;
            case 'user_profile_analysis':
                data = { user_id: localStorage.getItem('userId') };
                break;
            case 'historical_data_analysis':
                data = {
                    ticker: inputValue,
                    start_date: startDate,
                    end_date: endDate
                };
                break;
            case 'investment_recommendation':
                data = {
                    portfolio: portfolio.stocks ? portfolio.stocks.map(stock => stock.symbol) : [],
                    risk_profile: settings.risk_profile || 'moderate'
                };
                break;
            default:
                data = { input: inputValue };
                break;
        }
        const userMessage = { role: 'user', content: inputValue };
        setMessages(prevMessages => [userMessage, ...prevMessages]);
        try {
            await axios.post(process.env.REACT_APP_API_URL + '/chat_history', userMessage);
        } catch (error) {
            console.error('Error saving user message to chat history:', error);
        }

        try {
            const response = await axios.post(`${process.env.REACT_APP_API_URL}/agent/${agentName}`, data);
            let newMessage = {
                role: 'assistant',
                content: typeof response.data === 'string' ? response.data : response.data.content || 'Pas de contenu reçu de l\'agent'
            };
            if (response.data.graphs) {
                newMessage.graphs = response.data.graphs;
            }
            setMessages(prevMessages => [...prevMessages, newMessage]);

            try {
                await axios.post(process.env.REACT_APP_API_URL + '/chat_history', newMessage);
            } catch (saveError) {
                console.error('Error saving agent message to chat history:', saveError);
            }
        } catch (error) {
            console.error(`Error calling ${agentName} agent:`, error);
            const errorMessage = {
                role: 'assistant',
                content: `Error: ${error.response?.data?.error || error.message}`
            };
            setMessages(prevMessages => [...prevMessages, errorMessage]);

            try {
                await axios.post(process.env.REACT_APP_API_URL + '/chat_history', errorMessage);
            } catch (saveError) {
                console.error('Error saving error message to chat history:', saveError);
            }
        } finally {
            setLoading(false);
        }
    };

    const handleFileUpload = async (e) => {
        const file = e.target.files[0];
        if (file && file.type === 'application/pdf') {
            setFile(file);
            setLoading(true);
            const formData = new FormData();
            formData.append('file', file);
            try {
                const response = await axios.post(process.env.REACT_APP_API_URL + '/upload_pdf', formData, {
                    headers: { 'Content-Type': 'multipart/form-data' }
                });
                setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: JSON.stringify(response.data, null, 2) }]);
            } catch (error) {
                console.error('Error uploading PDF:', error);
            } finally {
                setLoading(false);
            }
        }
    };
    const handlePDFUpload = async (e) => {
        const file = e.target.files[0];
        if (file && file.type === 'application/pdf') {
            setLoading(true);
            const formData = new FormData();
            formData.append('file', file);
            try {
                const response = await axios.post(process.env.REACT_APP_API_URL + '/upload_pdf', formData, {
                    headers: { 'Content-Type': 'multipart/form-data' }
                });
                setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: JSON.stringify(response.data, null, 2) }]);
            } catch (error) {
                console.error('Error uploading PDF:', error);
            } finally {
                setLoading(false);
            }
        }
    };

    useEffect(() => {
        const token = localStorage.getItem('token');
        if (token) {
            setIsLoggedIn(true);
            axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
            fetchPortfolio();
        } else {
            setIsLoggedIn(false);
        }
    }, []);

    const handleDragOver = (e) => {
        e.preventDefault();
    };

    const handleDrop = (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file && file.type === 'application/pdf') {
            handlePDFUpload({ target: { files: [file] } });
        }
    };

    // Assurez-vous d'inclure le token dans toutes les requêtes
    axios.interceptors.request.use(
        (config) => {
            const token = localStorage.getItem('token');
            if (token) {
                config.headers['Authorization'] = `Bearer ${token}`;
            }
            return config;
        },
        (error) => {
            return Promise.reject(error);
        }
    );

    const handleLogin = () => {
        setIsLoggedIn(true);
        // Assurez-vous que le token est stocké dans localStorage
        const token = localStorage.getItem('token');
        if (token) {
            axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        }
    };

    const handleLogout = () => {
        logout();
        setIsLoggedIn(false);
    };

    const runBacktest = async () => {
        if (!portfolio || !portfolio.stocks || portfolio.stocks.length === 0) {
            alert("Portfolio is empty. Please add some stocks before running the backtest.");
            return;
        }

        try {
            const response = await axios.post(process.env.REACT_APP_API_URL + '/backtest', {
                portfolio: portfolio,
                start_date: startDate,
                end_date: endDate
            });
            setBacktestResults(response.data);
            setOpenBacktest(true);
        } catch (error) {
            console.error("Error running backtest:", error);
            if (error.response && error.response.data && error.response.data.error) {
                alert(`Error running backtest: ${error.response.data.error}`);
            } else {
                alert('Error running backtest. Please try again.');
            }
        }
    };

    const compareWithBenchmark = async () => {
        try {
            const response = await axios.post(process.env.REACT_APP_API_URL + '/compare_portfolios', {
                portfolio: portfolio.stocks, // Assurez-vous que c'est bien un tableau d'objets stock
                benchmark: benchmark,
                start_date: comparisonStartDate,
                end_date: comparisonEndDate
            });
            setComparisonResults(response.data);
            setOpenComparison(true);
        } catch (error) {
            console.error("Error comparing portfolios:", error);
            if (error.response) {
                console.error("Response data:", error.response.data);
                console.error("Response status:", error.response.status);
            }
            alert('Error comparing portfolios. Please try again.');
        }
    };

    const onClearChat = useCallback(async () => {
        try {
            await axios.post(process.env.REACT_APP_API_URL + '/clear_chat');
            setMessages([]);
            setConversationId(null);
            alert('Chat history cleared successfully');
        } catch (error) {
            console.error('Error clearing chat history:', error);
            alert('Error clearing chat history. Please try again.');
        }
    }, []);

    const handleSubmit = async (e, inputValue) => {
        e.preventDefault();
        if (!inputValue) return;

        setLoading(true);
        const newMessage = { role: 'user', content: inputValue };
        setMessages(prevMessages => [...prevMessages, newMessage]);

        try {
            const response = await axios.post(process.env.REACT_APP_API_URL + '/chat', {
                message: inputValue,
                conversation_id: conversationId
            }, {
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.data && response.data.reply) {
                setConversationId(response.data.conversation_id);
                setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: response.data.reply }]);
            } else {
                throw new Error('Réponse invalide du serveur');
            }
        } catch (error) {
            console.error('Error sending message:', error);
            setMessages(prevMessages => [...prevMessages, { role: 'assistant', content: 'Désolé, une erreur est survenue. Veuillez réessayer.' }]);
        } finally {
            setLoading(false);
        }
    };

    if (!isLoggedIn) {
        return (
            <ThemeProvider theme={theme}>
                <CssBaseline />
                <Container maxWidth="sm">
                    <Box mt={4}>
                        {showLogin ? (
                            <>
                                <Login onLogin={handleLogin} />
                                <Button onClick={() => setShowLogin(false)}>
                                    Pas de compte ? S'inscrire
                                </Button>
                            </>
                        ) : (
                            <>
                                <Register onRegisterSuccess={() => setShowLogin(true)} />
                                <Button onClick={() => setShowLogin(true)}>
                                    Déjà un compte ? Se connecter
                                </Button>
                            </>
                        )}
                    </Box>
                </Container>
            </ThemeProvider>
        );
    }

    return (
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <ResponsiveAppContent
                darkMode={darkMode}
                setDarkMode={setDarkMode}
                drawerOpen={open}
                setDrawerOpen={setOpen}
                // Passez toutes les autres props nécessaires ici
                handleLogout={handleLogout}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
                messages={messages}
                handleSubmit={handleSubmit}
                loading={loading}
                handlePDFUpload={handlePDFUpload}
                handleAgentCall={handleAgentCall}
                handleFileUpload={handleFileUpload}
                file={file}
                clearChatHistory={clearChatHistory}
                portfolio={portfolio}
                portfolioLoading={portfolioLoading}
                openBacktest={openBacktest}
                setOpenBacktest={setOpenBacktest}
                openComparison={openComparison}
                setOpenComparison={setOpenComparison}
                runBacktest={runBacktest}
                compareWithBenchmark={compareWithBenchmark}
                startDate={startDate}
                setStartDate={setStartDate}
                endDate={endDate}
                setEndDate={setEndDate}
                benchmark={benchmark}
                setBenchmark={setBenchmark}
                comparisonStartDate={comparisonStartDate}
                setComparisonStartDate={setComparisonStartDate}
                comparisonEndDate={comparisonEndDate}
                setComparisonEndDate={setComparisonEndDate}
                backtestResults={backtestResults}
                comparisonResults={comparisonResults}
                agentInputRef={agentInputRef}
            />
        </ThemeProvider>
    );
}

// Nouveau composant qui gère la requête média
function ResponsiveAppContent(props) {
    const isMobile = useMediaQuery((theme) => theme.breakpoints.down('sm'));

    return <AppContent {...props} isMobile={isMobile} />;
}

function AppContent({
    darkMode,
    setDarkMode,
    drawerOpen,
    setDrawerOpen,
    handleLogout,
    activeTab,
    setActiveTab,
    messages,
    handleSubmit,
    loading,
    handlePDFUpload,
    handleAgentCall,
    handleFileUpload,
    file,
    clearChatHistory,
    portfolio,
    portfolioLoading,
    openBacktest,
    setOpenBacktest,
    openComparison,
    setOpenComparison,
    runBacktest,
    compareWithBenchmark,
    startDate,
    setStartDate,
    endDate,
    setEndDate,
    benchmark,
    setBenchmark,
    comparisonStartDate,
    setComparisonStartDate,
    comparisonEndDate,
    setComparisonEndDate,
    backtestResults,
    comparisonResults,
    isMobile,
    agentInputRef,
}) {
    const [anchorEl, setAnchorEl] = React.useState(null);

    const handleMenu = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleClose = () => {
        setAnchorEl(null);
    };

    return (
        <Box sx={{ display: 'flex' }}>
            <AppBar position="fixed" sx={{ zIndex: (theme) => theme.zIndex.drawer + 1 }}>
                <Toolbar>
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={() => setDrawerOpen(!drawerOpen)}
                        sx={{ marginRight: 2, ...(drawerOpen && { display: 'none' }) }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <img src="/logo.jpg" alt="FinPilot Logo" style={{ height: 40, marginRight: 16 }} />
                    <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
                        FinPilot
                    </Typography>
                    <Box sx={{ display: { xs: 'none', md: 'flex' } }}>
                        <IconButton color="inherit">
                            <Badge badgeContent={4} color="secondary">
                                <NotificationsIcon />
                            </Badge>
                        </IconButton>
                        <IconButton
                            edge="end"
                            aria-label="account of current user"
                            aria-haspopup="true"
                            onClick={handleMenu}
                            color="inherit"
                        >
                            <AccountCircle />
                        </IconButton>
                    </Box>
                    <FormControlLabel
                        control={<Switch checked={darkMode} onChange={() => setDarkMode(!darkMode)} />}
                        label="Mode Sombre"
                        sx={{ ml: 2 }}
                    />
                </Toolbar>
            </AppBar>
            <Drawer
                variant={isMobile ? "temporary" : "permanent"}
                open={isMobile ? drawerOpen : true}
                onClose={() => setDrawerOpen(false)}
                sx={{
                    width: drawerWidth,
                    flexShrink: 0,
                    [`& .MuiDrawer-paper`]: {
                        width: drawerWidth,
                        boxSizing: 'border-box',
                        ...(isMobile && {
                            top: 56, // Ajustez selon la hauteur de votre AppBar sur mobile
                            height: 'calc(100% - 56px)',
                        }),
                    },
                }}
            >
                <Toolbar />
                <Box sx={{ overflow: 'auto' }}>
                    <List>
                        {[
                            { text: 'Copilote', icon: <ChatIcon /> },
                            { text: 'Agents', icon: <GroupWorkIcon /> },
                            { text: 'Analyse PDF', icon: <PictureAsPdfIcon /> },
                            { text: 'Paramètres', icon: <SettingsIcon /> },
                            { text: 'Portefeuille', icon: <AccountBalanceIcon /> },
                            { text: 'Sentiment du Marché', icon: <TrendingUpIcon /> },
                            { text: 'Recommandation d\'Investissement', icon: <MonetizationOnIcon /> },
                            { text: 'Analyse de Données Historiques', icon: <HistoryIcon /> },
                            { text: 'Analyse du Profil Utilisateur', icon: <PersonIcon /> }
                        ].map((item, index) => (
                            <ListItem button key={item.text} onClick={() => setActiveTab(index)}>
                                <ListItemIcon>
                                    {item.icon}
                                </ListItemIcon>
                                <ListItemText primary={item.text} />
                            </ListItem>
                        ))}
                    </List>
                </Box>
            </Drawer>
            <Box component="main" sx={{ flexGrow: 1, p: 3 }}>
                <Toolbar />
                <Stack spacing={3}>
                    <Fade in={true} timeout={1000}>
                        <Slide direction="up" in={true} mountOnEnter unmountOnExit>
                            <Paper elevation={3} sx={{ p: 3, borderRadius: 2 }}>
                                {activeTab === 0 && (
                                    <>
                                        <ChatBox
                                            messages={messages}
                                            handleSubmit={handleSubmit}
                                            loading={loading}
                                        />
                                        <input
                                            type="file"
                                            accept=".pdf"
                                            onChange={handlePDFUpload}
                                            style={{ display: 'none' }}
                                            id="pdf-upload"
                                        />
                                        <label htmlFor="pdf-upload">
                                            <Button variant="contained" component="span" color="secondary" sx={{ mt: 2 }}>
                                                Télécharger PDF
                                            </Button>
                                        </label>
                                        <Typography variant="body2" sx={{ mt: 1, mb: 2 }}>
                                            Vous pouvez aussi glisser-déposer un fichier PDF ici
                                        </Typography>
                                    </>
                                )}
                                {activeTab === 1 && (
                                    <>
                                        <TextField
                                            id="agent-input"
                                            label="Entrée pour l'agent"
                                            variant="outlined"
                                            fullWidth
                                            margin="normal"
                                            inputRef={agentInputRef}
                                        />
                                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 2 }}>
                                            {['document', 'sentiment', 'financial_modeling', 'portfolio_optimization', 'risk_management', 'reporting', 'compliance', 'market_sentiment', 'user_profile_analysis', 'historical_data_analysis', 'investment_recommendation'].map((agent) => (
                                                <Button
                                                    key={agent}
                                                    onClick={() => handleAgentCall(agent)}
                                                    variant="contained"
                                                    color="primary"
                                                    disabled={loading}
                                                >
                                                    {agent.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}
                                                </Button>
                                            ))}
                                        </Box>
                                        <ChatBox
                                            messages={messages}
                                            handleSubmit={handleSubmit}
                                            loading={loading}
                                            customInput={agentInputRef.current ? agentInputRef.current.value : ''}
                                            disableInput={true}
                                        />
                                    </>
                                )}
                                {activeTab === 2 && (
                                    <>
                                        <input
                                            type="file"
                                            accept=".pdf"
                                            onChange={handleFileUpload}
                                            style={{ display: 'none' }}
                                            id="pdf-upload"
                                        />
                                        <label htmlFor="pdf-upload">
                                            <Button variant="contained" component="span" color="primary" disabled={loading}>
                                                Télécharger PDF
                                            </Button>
                                        </label>
                                        {file && <Typography variant="body1" sx={{ mt: 2 }}>{file.name}</Typography>}
                                        {loading && <CircularProgress sx={{ mt: 2 }} />}
                                        <List>
                                            {messages.map((message, index) => (
                                                <ListItem key={index} alignItems="flex-start">
                                                    <ListItemText
                                                        primary={message.role === 'user' ? 'Vous' : 'IA'}
                                                        secondary={<MessageContent content={message.content} />}
                                                    />
                                                </ListItem>
                                            ))}
                                        </List>
                                    </>
                                )}
                                {activeTab === 3 && <Settings onClearChat={clearChatHistory} />}
                                {activeTab === 4 && <Portfolio />}
                                {activeTab === 5 && (
                                    <ErrorBoundary>
                                        {portfolioLoading ? (
                                            <Typography>Chargement du portfolio...</Typography>
                                        ) : portfolio ? (
                                            <Dashboard portfolio={portfolio} />
                                        ) : (
                                            <Typography>Erreur lors du chargement du portfolio</Typography>
                                        )}
                                    </ErrorBoundary>
                                )}
                                {activeTab === 6 && <MarketSentiment />}
                                {activeTab === 7 && <InvestmentRecommendation />}
                                {activeTab === 8 && <HistoricalDataAnalysis />}
                                {activeTab === 9 && <UserProfileAnalysis />}

                                <Box sx={{ mt: 3, display: 'flex', gap: 2 }}>
                                    <Button onClick={() => setOpenBacktest(true)} variant="outlined">Lancer Backtest</Button>
                                    <Button onClick={() => setOpenComparison(true)} variant="outlined">Comparer avec Benchmark</Button>
                                </Box>

                                <Dialog
                                    open={openBacktest}
                                    onClose={() => setOpenBacktest(false)}
                                    fullWidth
                                    maxWidth="lg"
                                >
                                    <DialogTitle>Résultats du Backtest</DialogTitle>
                                    <DialogContent>
                                        <TextField
                                            label="Date de début"
                                            type="date"
                                            value={startDate}
                                            onChange={(e) => setStartDate(e.target.value)}
                                            InputLabelProps={{ shrink: true }}
                                            fullWidth
                                            margin="normal"
                                        />
                                        <TextField
                                            label="Date de fin"
                                            type="date"
                                            value={endDate}
                                            onChange={(e) => setEndDate(e.target.value)}
                                            InputLabelProps={{ shrink: true }}
                                            fullWidth
                                            margin="normal"
                                        />
                                        <Button onClick={runBacktest} variant="contained" sx={{ mt: 2 }}>Lancer Backtest</Button>
                                        {backtestResults && (
                                            <Box sx={{ mt: 2 }}>
                                                <Typography>Rendement Total : {(backtestResults.total_return * 100).toFixed(2)}%</Typography>
                                                <Typography>Rendement Annualisé : {(backtestResults.annualized_return * 100).toFixed(2)}%</Typography>
                                                <Typography>Volatilité : {(backtestResults.volatility * 100).toFixed(2)}%</Typography>
                                                <Typography>Ratio de Sharpe : {backtestResults.sharpe_ratio.toFixed(2)}</Typography>
                                                <Box sx={{ width: '100%', height: 400, mt: 2 }}>
                                                    <ResponsiveContainer width="100%" height="100%">
                                                        <LineChart data={backtestResults.portfolio_values.map((value, index) => ({ date: index, value }))}>
                                                            <XAxis
                                                                dataKey="date"
                                                                tickFormatter={(tick) => {
                                                                    const date = new Date(startDate);
                                                                    date.setDate(date.getDate() + tick);
                                                                    return date.toLocaleDateString();
                                                                }}
                                                                interval={Math.floor(backtestResults.portfolio_values.length / 5)}
                                                            />
                                                            <YAxis
                                                                domain={['dataMin', 'dataMax']}
                                                                tickFormatter={(value) => `$${value.toLocaleString()}`}
                                                            />
                                                            <CartesianGrid strokeDasharray="3 3" />
                                                            <Tooltip
                                                                formatter={(value) => [`$${value.toLocaleString()}`, "Portfolio Value"]}
                                                                labelFormatter={(label) => {
                                                                    const date = new Date(startDate);
                                                                    date.setDate(date.getDate() + label);
                                                                    return date.toLocaleDateString();
                                                                }}
                                                            />
                                                            <Legend />
                                                            <Line type="monotone" dataKey="value" stroke="#8884d8" dot={false} name="Portfolio Value" />
                                                        </LineChart>
                                                    </ResponsiveContainer>
                                                </Box>
                                            </Box>
                                        )}
                                    </DialogContent>
                                    <DialogActions>
                                        <Button onClick={() => setOpenBacktest(false)}>Fermer</Button>
                                    </DialogActions>
                                </Dialog>

                                <Dialog
                                    open={openComparison}
                                    onClose={() => setOpenComparison(false)}
                                    fullWidth
                                    maxWidth="lg"
                                >
                                    <DialogTitle>Comparaison de Portefeuille</DialogTitle>
                                    <DialogContent>
                                        <Select
                                            value={benchmark}
                                            onChange={(e) => setBenchmark(e.target.value)}
                                            fullWidth
                                            margin="normal"
                                        >
                                            <MenuItem value="SPY">S&P 500 (SPY)</MenuItem>
                                            <MenuItem value="QQQ">Nasdaq 100 (QQQ)</MenuItem>
                                            <MenuItem value="IWM">Russell 2000 (IWM)</MenuItem>
                                        </Select>
                                        <TextField
                                            label="Date de début"
                                            type="date"
                                            value={comparisonStartDate}
                                            onChange={(e) => setComparisonStartDate(e.target.value)}
                                            InputLabelProps={{ shrink: true }}
                                            fullWidth
                                            margin="normal"
                                        />
                                        <TextField
                                            label="Date de fin"
                                            type="date"
                                            value={comparisonEndDate}
                                            onChange={(e) => setComparisonEndDate(e.target.value)}
                                            InputLabelProps={{ shrink: true }}
                                            fullWidth
                                            margin="normal"
                                        />
                                        {comparisonResults && (
                                            <Box sx={{ mt: 2 }}>
                                                <Typography>Rendement du Portefeuille : {(comparisonResults.portfolio_return * 100).toFixed(2)}%</Typography>
                                                <Typography>Rendement du Benchmark : {(comparisonResults.benchmark_return * 100).toFixed(2)}%</Typography>
                                                <Typography>Volatilité du Portefeuille : {(comparisonResults.portfolio_volatility * 100).toFixed(2)}%</Typography>
                                                <Typography>Volatilité du Benchmark : {(comparisonResults.benchmark_volatility * 100).toFixed(2)}%</Typography>
                                                <Typography>Ratio de Sharpe du Portefeuille : {comparisonResults.portfolio_sharpe?.toFixed(2) || 'N/A'}</Typography>
                                                <Typography>Ratio de Sharpe du Benchmark : {comparisonResults.benchmark_sharpe?.toFixed(2) || 'N/A'}</Typography>
                                                {comparisonResults.portfolio_cumulative && comparisonResults.benchmark_cumulative && (
                                                    <Box sx={{ width: '100%', height: 400, mt: 2 }}>
                                                        <ResponsiveContainer width="100%" height="100%">
                                                            <LineChart data={comparisonResults.portfolio_cumulative.map((value, index) => ({
                                                                date: index,
                                                                portfolio: value,
                                                                benchmark: comparisonResults.benchmark_cumulative[index]
                                                            }))}>
                                                                <XAxis
                                                                    dataKey="date"
                                                                    tickFormatter={(tick) => {
                                                                        const date = new Date(comparisonStartDate);
                                                                        date.setDate(date.getDate() + tick);
                                                                        return date.toLocaleDateString();
                                                                    }}
                                                                    interval={Math.floor(comparisonResults.portfolio_cumulative.length / 5)}
                                                                />
                                                                <YAxis
                                                                    tickFormatter={(value) => `${(value * 100).toFixed(0)}%`}
                                                                />
                                                                <CartesianGrid strokeDasharray="3 3" />
                                                                <Tooltip
                                                                    formatter={(value) => [`${(value * 100).toFixed(2)}%`, ""]}
                                                                    labelFormatter={(label) => {
                                                                        const date = new Date(comparisonStartDate);
                                                                        date.setDate(date.getDate() + label);
                                                                        return date.toLocaleDateString();
                                                                    }}
                                                                />
                                                                <Legend />
                                                                <Line type="monotone" dataKey="portfolio" stroke="#8884d8" dot={false} name="Portefeuille" />
                                                                <Line type="monotone" dataKey="benchmark" stroke="#82ca9d" dot={false} name="Benchmark" />
                                                            </LineChart>
                                                        </ResponsiveContainer>
                                                    </Box>
                                                )}
                                            </Box>
                                        )}
                                    </DialogContent>
                                    <DialogActions>
                                        <Button onClick={compareWithBenchmark} variant="contained" color="primary">Comparer</Button>
                                        <Button onClick={() => setOpenComparison(false)}>Fermer</Button>
                                    </DialogActions>
                                </Dialog>
                            </Paper>
                        </Slide>
                    </Fade>
                </Stack>
            </Box>
            <Menu
                id="menu-appbar"
                anchorEl={anchorEl}
                anchorOrigin={{
                    vertical: 'top',
                    horizontal: 'right',
                }}
                keepMounted
                transformOrigin={{
                    vertical: 'top',
                    horizontal: 'right',
                }}
                open={Boolean(anchorEl)}
                onClose={handleClose}
            >
                <MenuItem onClick={handleClose}>Profil</MenuItem>
                <MenuItem onClick={handleClose}>Mon compte</MenuItem>
                <MenuItem onClick={handleLogout}>Déconnexion</MenuItem>
            </Menu>
        </Box>
    );
}


export default App;
>>>

./copilot/src/Settings.js :
<<<
import React, { useState, useEffect } from 'react';
import { TextField, Button, Select, MenuItem, Chip, Box, FormControl, InputLabel } from '@mui/material';
import axios from 'axios';

const api = axios.create({
    baseURL: process.env.REACT_APP_API_URL,
    headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    },
    withCredentials: true
});

function Settings({ onClearChat }) {
    const [settings, setSettings] = useState({
        defaultPortfolioValue: 100000,
        riskProfile: 'moderate',
        preferredSectors: [],
        theme: 'light'
    });

    useEffect(() => {
        fetchSettings();
    }, []);

    const fetchSettings = async () => {
        try {
            const response = await axios.get(
                `${process.env.REACT_APP_API_URL}/settings`,
                {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                }
            );
            setSettings(response.data);
        } catch (error) {
            console.error('Erreur lors de la récupération des paramètres:', error);
            if (error.response) {
                console.error('Données de réponse:', error.response.data);
            }
        }
    };


    const handleSettingsChange = (setting, value) => {
        setSettings(prevSettings => ({ ...prevSettings, [setting]: value }));
    };

    const clearChat = async () => {
        try {
            const token = localStorage.getItem('token');
            await axios.post(process.env.REACT_APP_API_URL + '/clear_chat', {}, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            alert('Historique du chat effacé avec succès');
            onClearChat();
        } catch (error) {
            console.error('Erreur lors de l\'effacement de l\'historique du chat:', error);
            alert('Erreur lors de l\'effacement de l\'historique du chat. Veuillez réessayer.');
        }
    };

    const saveSettings = async () => {
        try {
            const response = await axios.post(
                `${process.env.REACT_APP_API_URL}/settings`,
                settings,
                {
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                }
            );
            console.log('Réponse du serveur:', response.data);
            alert('Paramètres sauvegardés avec succès');
        } catch (error) {
            console.error('Erreur lors de la sauvegarde des paramètres:', error);
            if (error.response) {
                console.error('Données de réponse:', error.response.data);
            }
            alert(`Erreur lors de la sauvegarde des paramètres: ${error.message}`);
        }
    };

    return (
        <Box>
            <TextField
                label="Valeur par défaut du portefeuille"
                value={settings.defaultPortfolioValue}
                onChange={(e) => handleSettingsChange('defaultPortfolioValue', Number(e.target.value))}
                type="number"
                fullWidth
                margin="normal"
            />
            <FormControl fullWidth margin="normal">
                <InputLabel>Profil de risque</InputLabel>
                <Select
                    value={settings.riskProfile}
                    onChange={(e) => handleSettingsChange('riskProfile', e.target.value)}
                >
                    <MenuItem value="low">Faible</MenuItem>
                    <MenuItem value="moderate">Modéré</MenuItem>
                    <MenuItem value="high">Élevé</MenuItem>
                </Select>
            </FormControl>
            <FormControl fullWidth margin="normal">
                <InputLabel>Secteurs préférés</InputLabel>
                <Select
                    multiple
                    value={settings.preferredSectors}
                    onChange={(e) => handleSettingsChange('preferredSectors', e.target.value)}
                    renderValue={(selected) => (
                        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                            {selected.map((value) => (
                                <Chip key={value} label={value} />
                            ))}
                        </Box>
                    )}
                >
                    <MenuItem value="Technology">Technologie</MenuItem>
                    <MenuItem value="Healthcare">Santé</MenuItem>
                    <MenuItem value="Finance">Finance</MenuItem>
                    <MenuItem value="Energy">Énergie</MenuItem>
                </Select>
            </FormControl>
            <FormControl fullWidth margin="normal">
                <InputLabel>Thème</InputLabel>
                <Select
                    value={settings.theme}
                    onChange={(e) => handleSettingsChange('theme', e.target.value)}
                >
                    <MenuItem value="light">Clair</MenuItem>
                    <MenuItem value="dark">Sombre</MenuItem>
                </Select>
            </FormControl>
            <Button
                onClick={clearChat}
                variant="contained"
                color="secondary"
                style={{ marginTop: '20px', marginRight: '10px' }}
            >
                Effacer l'historique du chat
            </Button>
            <Button
                onClick={saveSettings}
                variant="contained"
                color="primary"
                style={{ marginTop: '20px' }}
            >
                Sauvegarder les paramètres
            </Button>
        </Box>
    );
}

export default Settings;
>>>

